# 性能之 防抖和节流

### 目录

1 [预读文档](#1)

2 [防抖实现](#2)

3 [节流实现](#3)


## <span id="1">一 预读文档 </span>

1 阅读文档有

01 [JS专题之 跟着underscore学防抖](https://github.com/mqyqingfeng/Blog/issues/22)

02 [JS专题之 跟着underscore学节流](https://github.com/mqyqingfeng/Blog/issues/26)

03 [一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧](https://juejin.im/post/5cef46226fb9a07eaf2b7516)

阅读原因: 直接参考文档


## <span id="2">二 防抖 </span>

1 Q: 什么是防抖(debounce)

A:

S1 当用户的操作会引起 频繁的JS计算/网络请求等时，就要对事件的 响应回调进行频率限制，以保证性能

S2 防抖: N秒内 函数只会被执行一次，如果 在N秒内再次被触发，则`(清除定时器) 重新计算延迟时间`


2 Q: 如何实现防抖

A: 代码见下:

```js

function debounce(fn, wait, immediate=true) {
  let timer  //S1 闭包，这样再次触发事件时, 上次绑定的值不会丢失
  let result

  let _debounde = function(...args) {  // S2.1 防止事件回调函数中的 event等参数丢失
    let ctx = this   // S2.2 防止事件回调函数中的 this指向丢失(指向对应的DOM元素)

    if (timer) {   // S3 当触发时间 t1<wait时, 需要清除之前的 定时器函数执行
      clearTimeout(timer)  // 但是注意，clearTimeout不会清除 timer的值(一个定时器函数 Id)
    }


    if (immediate) {
      let callNow = !timer

      // S4 t1>wait时，才会再次执行fn; t1<wait, timer一直不会重置为null，所以一直不会再次执行fn
      timer = setTimeout(function(){
        timer = null
      }, wait)

      if (callNow) { result = fn.apply(ctx, args) }

    } else {  // 非立即执行时，执行原逻辑
      timer = setTimeout(function(){
        fn.apply(ctx, args)
      }, wait)
    }

    return result  // S5 fn回调可能会有返回值
  }

  _debounde.cancel = function() {  // S6 取消功能，执行后会立刻执行一次immediate的逻辑
    clearTimeout(timeout)
    timeout = null  // 关键就是立刻重置了timer的值
  };

  return _debounde

}

```


## <span id="3">三 节流 </span>


1 Q: 什么是节流(throttle)

A:

S1 一段时间内不管触发多少次事件，都只按固定的频率响应对应回调

S2 防抖的核心是 `不满足wait 就重置`, 节流的核心是 `不满足wait 就忽略`


2 Q: 如何实现节流

A:

S1 方法1: 时间戳法, 代码见下

```js
function throttle(fn, wait) {
  let previos = 0
  let self, args
  return function() {
    self = this, args = arguments

    let now = +new Date()
    if (now - previous >= wait) {
      fn.apply(self, args)
      previous = now
    }
  }
}
```

S2 方法2: 定时器法, 代码见下

```js
function throttle(fn, wait) {
  let timer, self, args

  return function() {
    timer = setTimeout(function(){
      timer = null
    }, wait)

    if (!timer) {fn.apply(self, args)}
  }
}
```

S3 最终综合版本见下

```js
function throttle(func, wait, options = {}) {
  let timer, result, cxt, args
  let previous = 0;
  
  let later = function () {
    // S4 首次不执行时，pervious会重置为0, 从而保证S2逻辑执行，下次会再次走 定时器逻辑
    previous = options.leading ? Date.now() : 0
    timer = null;
    result = func.apply(cxt, args);

    // S5 执行完回调，会重置context和args，释放闭包内存
    if (!timer) cxt = args = null;
  };


  let throttled = function () {
    cxt = this;
    args = arguments;   // S1 绑定正确的 事件回调函数的 this指向和event参数对象

    let now = Date.now()

    // S2.1 leading为false时，pervious会设置为当前值，从而保证首次执行的 remaining > 0
    // S2.2 leading为false时, 则 永远不会使用 时间戳部分来 控制节流
    if (!previous && options.leading === false) previous = now;

    let remaining = wait - (now - previous);
 
    if (remaining <= 0 || remaining > wait) {
      // S6 如果定时器部分被延误执行了，则去除它的 设置部分，防止干扰到 时间戳部分
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      previous = now;
      func.apply(cxt, args);
  
      if (!timer) cxt = args = null;  // S7 同S5

    // S3.1 remaing>0时, 且还未设置过timer
    // S3.2 如果remaing还是>0(间隔t1<wait)，但是timer回调还未执行，就会被忽略
    // S3.3 如果trailing设置了为假，则 永远不会使用 定时器部分来 控制节流
    } else if (!timer && options.trailing !== false) {
      timer = setTimeout(later, remaining);
    }

    return result
  };

  throttled.cancel = function () {
    clearTimeout(timer);
    timer = null;
    previous = 0;
  }

  return throttled
}
```