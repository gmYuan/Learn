# JS基础之 垃圾回收详解

目录:

1 [预读文档](#1)

2 [内存生命周期](#2)

3 [垃圾回收](#3)


## <span id="1">1 预读文档 </span>

01 [JS中的内存管理](https://juejin.im/post/5d0706a6f265da1bc23f77a9)

阅读原因: 直接参考文档


## <span id="2"> 2 内存生命周期 </span>

1 Q: 内存生命周期 有哪些

A:

浏览器的内存 有以下3个生命周期：

- S1 分配内存: 通常是在 申明变量/函数/对象时，浏览器会自动分配内存空间存储值;

- S2 使用内存: 当对保存在内存中的值 进行读取操作时;

- S3 回收内存: 垃圾收集器会周期性 找出不再使用的变量，然后释放其内存 => 即`垃圾回收机制`


## <span id="3"> 3 垃圾回收 </span>

1 Q: 浏览器如何自动实现 垃圾回收

A1 `引用计数`

S1 记录每个值 被引用的次数

S2 如果一个值的引用次数是0，就表示这个值不再使用，因此可以会将这块内存释放

S3 引用计数的最大问题是: `对象之间的 循环引用，会导致 对象永远不会被自动回收`

```js
// S1~S2
function test(){
  var a = {}     // a的引用次数为 0
  var b = a      // a的引用次数为 1
  var c = a;     // a的引用次数为 2
  var b = {};    //a的引用次数减1，为1
}

// S3.1 循环引用示例1
function fn() {
  var a = {};
  var b = {};
  a.pro = b;
  b.pro = a;
}

fn() //fn()执行完毕后, a 和 b仍然不会被清除


// S3.2 循环引用示例2
window.onload= function test2(){
  var obj = document.getElementById("element");
  obj.onclick = function test3(){
    // test3内部引用了外部的 obj,所以也是一个循环引用
  }  
}
// 即使页面移除了element元素，也会一直在内存中一直存在
```

A2 `标记清除`

S1 