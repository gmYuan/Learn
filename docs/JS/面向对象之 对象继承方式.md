# 面向对象之 对象继承方式

目录:

1 [预读文档](#1)

2 [继承方法实现](#2)


## <span id="1">1 预读文档 </span>

01 [JS深入之 继承的多种方式和优缺点](https://github.com/mqyqingfeng/Blog/issues/16)

02 [JavaScript常用八种继承方案](https://juejin.im/post/5bcb2e295188255c55472db0)

阅读原因: 直接参考文档


## <span id="2"> 2 继承方法实现 </span>

1 Q: JS中实现 对象继承的方式有哪些

A: 

S1 方法1: 原型链继承: `child.pty = new Parent()`

```js
function Parent() {
  this.prices = [20, 40]
}
Parent.prototype.showPrice = function() {
  console.log(this.prices)
}

function Child() {}
Child.prototype = new Parent()

let ex1 = new Child()   // ex1.__ptoto__ => Child.pty === obj: {prices} => Parent.pty
let ex2 = new Child()

ex1.prices.push(60)
ex2.showPrice()  // [20, 40, 60]


// 缺点: 引用类型的属性 会被所有实例共享 + 子类不能传入参数
```

S2 方法2: 借用构造函数: `Parent.call(this)`

```js
function Parent(price) {
  this.prices = [...[1], price]
}
Parent.prototype.showPrice = function() {
  console.log(this.prices)
}

function Child(price) {
  Parent.call(this, price)
}

let ex1 = new Child(2)   // ex1.prices = [1, 2] + ex1.__proto__ === Child.pty
let ex2 = new Child(3)   // ex2.prices = [1, 3] + ex2.pro === Child.pty

console.log(ex1.prices)   // [1, 2]
console.log(ex2.prices)   // [1, 3]
console.log(ex1.showPrice)  // undefined

// 缺点: 子类实例不能访问 父类原型上的方法 + 每次创建子类实例都会 调用一次父类
```

S3 方法3: 组合继承: `child.pro = new Parent +  Parent.call(this)`

```js
function Parent(name) {
  this.name = name
  this.prices = [1,3]
}
Parent.prototype.getName = function() {
  console.log(this.name)
}

function Child(name) {
  Parent.call(this, name)
}
Child.prototype = new Parent()    // Child.pty === {name, ages},  Child.pty.__proto__ ===  Parent.prototype
Child.prototype.constructor = Child;


let ex1 = new Child('name1')
let ex2 = new Child('name2')
ex1.prices.push(5)

console.log(ex1)    // {prices: [1, 3, 5],  name: "name1"}
console.log(ex2)    // {prices: [1, 3],  name: "name2"}
ex1.getName()       // name1

// 缺点: 子类实例 和 子类原型对象上 都会调用一次父类方法,  实例和原型对象上存在同名属性
```

S4 方法4: 原型式继承: `object.create的模拟实现`

```js
function createObj(parentObj) {
  function child() {}
  child.prototype = parentObj
  return new child()
}

let p1 = {name: 'test', prices: [2,4]}
let ex1 = createObj(p1)
let ex2 = createObj(p1)

ex1.prices.push(6)

console.log(ex1.prices)   // [2,4,6]
console.log(ex2.prices)  // [2,4,6]

// 缺点: 同原型链继承
```

S5 方法5: 寄生式继承: ``

```JS

function createObj (o) {
  let child = Object.create(o)
  child.sayName = function () {
    console.log('hi')
  }
  return child
}
// 缺点: 同原型链继承,主要作用是 为构造函数新增属性和方法，以增强函数
```


S5 方法6: 寄生组合式继承: `Parent.call(this) + 原型对象的 原型式继承`

```js
function Parent(name) {
  this.name = name
  this.ages = [2,3]
}
Parent.prototype.getName = function() {
  console.log(this.name)
}

function Child(name) {
  Parent.call(this, name)
}
let temp = function(){}
temp.prototype = Parent.prototype
Child.prototype = new temp()       // 不会再次执行Parent一次


let ex1 = new Child('name1')  
let ex2 = new Child('name2')
ex1.ages.push(4)

console.log(ex1)    // { ages: [2, 3, 4],  name: "name1" }
console.log(ex2)   // { ages: [2, 3],  name: "name2" }
ex1.getName()      // name1
```

ES6 Class的写法见下

```js
class Parent{
  constructor(name){
    this.name = name
  }
  getName() {
    console.log(this.name)  
  }
}

class Child extends Parent{
  constructor(name){
    super(name)               // super关键字作用: 调用继承 父类的实例属性/方法
    this.age = 20
  }

  playgame(){
    console.log('Men like playing games')
  }
}
```

ES5继承 和 ES6继承的区别

- ES5的继承 实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)

- ES6的继承 实质上是先创建父类的实例对象this，然后再用子类的构造函数 修改this;

  因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例 会报错