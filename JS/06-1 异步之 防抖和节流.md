# 异步之 防抖和节流

## 目录

1 [预读文档](#1)

2 [防抖实现](#2)

3 [节流实现](#3)


## <span id="1">一 预读文档 </span>

1 阅读文档有

1.1 [JS专题之 跟着underscore学防抖](https://github.com/mqyqingfeng/Blog/issues/22)

1.2 [JS专题之 跟着underscore学节流](https://github.com/mqyqingfeng/Blog/issues/26)

阅读原因: 直接参考文档


## <span id="2">二 防抖 </span>

1 Q: 什么是防抖(debounce)

A:

S1 当用户的操作会引起 频繁的JS计算/网络请求等时，就要对其事件响应回调进行频率限制，以保证性能

S2 防抖的限制原理类似于  每次法师读大过程中再次放大, 就会重新进行施法计时


2 Q: 实现防抖的难点

A: 

S1 如何重新进行施法计时: `清除之前已有的的回调计时 + 进行新的回调计时`


3 Q: 如何实现防抖

A: 防抖分为 非立即执行版 和 立即执行版, 代码见下: 

```js
// 1 非立即执行版
function deounce(func, wait) {
  var timer
  return function() {
    var self = this, args = arguments  // 绑定因异步延时 丢失的this 和 event对象

    clearTimeout(timer)
    timer = setTimeout(function() {
      func.apply(self, args)
    }, wait)
  }
}


// 2 立即执行版: 一开始立即执行 + 之后每次节流
function debounce(fn, wait, immediate) {
  var timer
  return function() {
    var self = this, args = arguments

    if (timer) {clearTimeout(timer)}   // S2 因为timer可能为null,所以要对其做个存在判断
    
    if (immediate) {
      var callnow = !timer
      timer = setTimeout(function(){  // S1  设置timer值: 小于wait又触发时则不执行fn + 大于wait时则执行fn => 取反timer的变量
        timer = null
      }, wait)
      if (callnow) { fn.apply(self, args) }
        
    } else {  // 非立即执行时，执行原逻辑
      timer = setTimeout(function(){
        fn.apply(self, args)
      }, wait)
    }
  }
}

```


## <span id="3">三 节流 </span>

### <span id="3.1"> 3.1 需求描述 </span>

1 Q: 什么是节流

A: 节流同样是用于优化 频繁触发的事件性能 

S1 防抖的核心是 触发事件后不断重设响应，而节流的核心是 触发事件后一段时间内只设置一次响应

S2 可以把节流理解为固定频率的子弹发射，一段时间内按多次射击，也只会发射一颗子弹


### <span id="3.2"> 3.2 代码实现 </span>

1 Q: 如何用时间戳方式实现节流

A: 代码实现如下

```js
function throttle(func, wait){
  let prev = 0
  let context, args    // 在这里声明，不用每次返回匿名处理函数时，就都创建一个新变量

  return function(){
    context = this
    args = arguments
    let now = + new Date()  
    if (now - prev > wait){
      func.call(context,args)
      prev = now
    }
  }

}

// 代码分析
// A1 第一次触发时，判断 当前时间，未到间隔时间则无响应

// A2 第二次触发 + 满足间隔，则触发响应 + 把当前时间作为之前时间

// A3 特点是初次会触发(prev为0) + 4.2s时不会触发(不满足1s的间隔)
```

2 Q: 如何用定时器方式 实现节流

A: 代码实现如下

```js
function throttle(func,wait){
  let context,args
  let timer, noOld
  
  return function(){
    context = this
    args = arguments
    noOld = !timer

    if (noOld) {
      timer = setTimeout(function(){
        func.call(context,args)
        timer = null
       },wait)
    }
 
  }// 对应匿名函数

}

// 代码分析
// A1 第一次触发时，timer为undefined + noOld为ture + 设置定时器timer=1
//        定时器的作用是 触发回调 + 设置timer为null

// A2 第二次触发 + 不满足间隔: timer为1 + noOld为false,不触发回调响应

// A3 第三次触发 + 满足间隔: 已执行回调 + timer被设置为null + 设置定时器timer=2

// A4 停止触发后，由于之前定时器的延迟效果，会再执行一次响应

```

综上，

时间戳方法: 事件会立刻执行，停止触发后不会再执行响应回调

定时器方法: 事件会在n秒后第一次执行（定时器原因)，停止触发后会再执行一次响应回调


3 Q: 如何用 时间戳+定时器 实现节流

A: 代码实现如下

```js
function throttle(func, wait){
  let timer, context, args
  let previous = 0
  let later = function later(){
    previous = + new Date()
    timer = null
    func.call(context, args)
  }

  let throttled = function(){
    let now = + new Date()
    let remaining = wait - (now - previous)   //声明记录 下次触发func 剩余的时间
    context = this
    args = arguments

    // 如果触发时 没有剩余的时间了或者 改了当前now的 系统时间
    if (remaining <=0 || remaining > wait){  
      if (timer){
        clearTimeout(timer)
        timer = null
      }
      previous = now
      func.call(context, args)
 
    } else if (!timer){                    // 如果 触发时小于间隔 + timer未设置
      timer = setTimeout(later, remaining)
    }
  } // 返回的响应

  return throttled
}


// 过程分析
// A1 前提: 预期的 wait=5s

// A2 第一次触发时: remaining一般情况下必<0 + tiemr为null => 更新记录时间 + 执行响应

// A3.1 第2次触发事件remaing=2: timer为null => 设置timer1,2s后加入一个异步队列
// A3.2 第3次触发事件remaing=1: 不执行任何操作
// A3.3 第4次触发事件remaing=0: 删除timer1标记 + 重置为ull + 更新时间执行响应 + 执行异步
//           异步的内容是: 更新时间 + timer为null + 执行响应

// A4.1 第5次触发事件remaing=3: 步骤同上...
```

### <span id="3.3"> 3.3 项目实现代码 </span>

1 Q: 实际项目中的实现代码是什么

A: 参见[QQ音乐- 懒加载和节流实现](https://github.com/gmYuan/QQ-music/blob/master/scripts/lazyload.js)


2 Q: IntersectionObserver 的使用方法是什么

A: S1 获取图片集合

S2 创建IntersectionObserver实例对象，传入回调函数 + 参数配置(用于附加条件 以触发回调函数)

S3 回调函数里会自动传入一个entries参数，它是一个 对象数组
    entries里的每个对象， 都有isIntersecting等7个属性

S4 实例对象有 observe/unobserve 等方法，observe方法每次只能观察一个元素

S5 在完成加载图片后，停止监听这个图片—— loadImage增加一个 监听/回调函数

以下是部分代码:

```JS
let imgs = [].slice.call(images)

let observer = new IntersectionObserver( (entries) => {
  // console.log(entries)
  entries.forEach(item => {
    if(item.isIntersecting){
      loadImage(item.target)
    }
  })
 })

 imgs.forEach( image => {
    observer.observe(image)
 })
```