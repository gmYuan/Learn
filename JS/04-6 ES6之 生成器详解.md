# ES6之 迭代器 + 生成器 详解

目录:

1 [预读文档](#1)

2 [生成器基本概念](#2)


## <span id="1"> 1 预读文档 </span>

1 [深入理解ES6](https://legacy.gitbook.com/book/oshotokill/understandinges6-simplified-chinese/details)

2 [Generator 函数的语法](http://es6.ruanyifeng.com/#docs/generator)

阅读原因: 直接参考文档


## <span id="2"> 2 生成器基本概念 </span>

1 Q: 什么是生成器, 有什么作用

A: S1 生成器是 return迭代器对象的特殊函数 + 内部用yield表达式来 返回迭代器的 当前状态

```js
function* foo() {
  yield 1
  yield 2
  yield 3
  yield 4
  yield 5
  return 6
}

for (let v of foo()) {
  console.log(v)          // 1 2 3 4 5
}

// S1 temp = foo(), temp = { next: {xxx}, [Symbol.iterator] = temp }

// S2 for..of自动调用  temp[Symbol.iterator](), 且 temp[Symbol.iterator]() === temp 为true  +  temp = { next: {xxx}, }

// S3 for..of自动调用 next()生成   {value: xxx, done: xxx}

// S4 yieldA 会自动在调用next()时，把A传入返回的{value: A, done: hasNoyield}
```


2 Q: yield表达式的作用是什么

A: S1 yield 返回当前迭代器的状态值，状态值就是`yield A`中的 A;

S2 `yield A`语句默认返回的值是undefined, 可以通过next(C),把C赋值给 `上一个yield表达式的返回值`

S3 每次执行next(),都会在yield出暂停，再次执行时从暂停出再继续

代码举例:

```js
function* f() {
  for(var i = 0; true; i++) {
    var reset = yield i;
    if(reset) { i = -1; }
  }
}

var g = f();

g.next()       // { value: 0, done: false }
g.next()       // { value: 1, done: false }
g.next(true)  // { value: 0, done: false },  因为ture被赋值给 上一次的yiled表达式返回值了
```


3 Q: 如何理解 生成器的throw方法

A: S1 生成器函数G返回的 迭代器对象i，具有`i.throw()方法`, 可以监测G函数内部程序是否报错

S2 G内部的try..catch只能捕获一次i.throw()抛出的错误，如果继续抛出错误，可被G函数内外 设置的 `try...catch`语句捕获;

若都没有 + 发生错误时, 程序会停止运行(即 `error被catch捕获的冒泡性`)

```js
var g = function* () {
  try {
    yield
  } catch (e) {
    console.log('内部捕获', e)
  }
};

var i = g()
i.next()

try {
  i.throw('a')
  i.throw('b')
} catch (e) {
  console.log('外部捕获', e)
}

// 内部捕获 a
// 外部捕获 b
```


4 Q: 如何理解 生成器的return方法

A: S1 `g.return(p1)`会终止迭代器的迭代过程，直接状态变成`{value: p1, done: true}`

```js
function* gen() {
  yield 1
  yield 2
  yield 3
}

var g = gen();

g.next()          // { value: 1, done: false }
g.return('foo')   // { value: "foo", done: true }
g.next()         // { value: undefined, done: true }
```


5 Q: yield* 表达式有什么作用

A: 在 A生成器中 执行B生成器的 迭代器 + 加入B中的yield语句到A中

S2 本质上, yield* 是 `for..of在 生成器C生成的迭代器D 中自动调用next()方法的 + 返回_step().value` 语法糖

```js
function* bar() {
  yield 'x'
  yield* foo()
  yield 'y'
}

// 本质上 等同于
function* bar() {
  yield 'x'
  for (let v of foo()) {
    yield v
  }
  yield 'y'
}


for (let v of bar()){
  console.log(v)        // "x", "a", "b", "y"
}
```