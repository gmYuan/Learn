# ES6之 迭代器 + 生成器 详解

目录:

1 [预读文档](#1)

2 [迭代器](#2) 

3 [生成器](#3)



## <span id="1"> 1 预读文档 </span>

1 [深入理解ES6](https://legacy.gitbook.com/book/oshotokill/understandinges6-simplified-chinese/details)

2 [Iterator 和 for...of 循环](http://es6.ruanyifeng.com/#docs/iterator)

阅读原因: 直接参考文档


## <span id="2"> 2 迭代器 </span>

1 Q: 什么是迭代器(Iterator), 有什么作用

A:

A1 迭代器: 具有next()方法的对象 + 内部的 next()又返回一个 具有value和done属性的 对象

A2 迭代器的作用是: 1. 为ES6所有可遍历对象提供一个统一的 访问数据方法;  2. 一定程度上弱化对for循环的使用依赖程度

用代码表示迭代器为:

```js
function createIterator(items) {
  let i = 0
  return {
    next() {
      let done = (i >= items.length ? true : false)
      let value = (done ? undefined : items[i++])
      return {
        value,
        done
      }
    }
  }
}

let iterator = createIterator([1, 2, 3])
console.log(iterator.next())          // "{ value: 1, done: false }"
console.log(iterator.next())         // "{ value: 2, done: false }"
console.log(iterator.next())         // "{ value: 3, done: false }"
console.log(iterator.next())        // "{ value: undefined, done: true }"
// 之后的所有调用
console.log(iterator.next())       // "{ value: undefined, done: true }"
```

2 Q: 什么是可迭代对象(Iterable), 它有什么特点

A: S1 在JS中, 如果一个对象A具有[symbol.itetaor]方法 + 该方法返回的是迭代器对象B, 那么对象A就是一个 可迭代对象

S2 可迭代对象的特点是: 可以通过`for...of语法` 访问其对象的内部数据

示例代码为:

```js
class RangeIterator {
  constructor(start, stop) {
    this.value = start;
    this.stop = stop;
  }

  [Symbol.iterator]() { return this; }      // new调用时,原型链上this指向实例对象 + 具有next()方法

  next() {
    var value = this.value;
    if (value < this.stop) {
      this.value++;
      return {done: false, value: value};
    }
    return {done: true, value: undefined};
  }
}

function range(start, stop) {
  return new RangeIterator(start, stop);
}


for (var value of range(0, 3)) {
  console.log(value);             // 0, 1, 2
}
```

3 Q: 有哪些语法操作会默认调用 迭代器next()方法

A: 解构赋值 / 扩展运算符 / for...of / Array.from() / yield* 等






## <span id="3"> 3 剩余参数rest </span>

1 Q: 剩余参数rest有哪些使用场景

A: S1 剩余参数: 可以把多个独立的参数 合并到一个数组中

所以可用于 函数传参，替代arguments对象

```js
// 例1: 使用示例
function add(...values) {
  let sum = 0
  values.reduce( (pre, cur) => {return sum = pre + cur})
  return sum
}

add(1, 2, 3) // 6
```

S2 剩余参数 + 解构赋值

```js

// 例2: 数组解构赋值
let colors = [ "red", "green", "blue" ]
let [ firstColor, ...restColors ] = colors

console.log(firstColor)             // "red"
console.log(restColors.length)     // 2
console.log(restColors[0])         // "green"
console.log(restColors[1])        // "blue"
```



## <span id="4"> 4 扩展运算符... </span>

1 Q: 扩展运算符... 有哪些使用场景

A: S1 用于函数传参，把一个数组分解成各个单独参数
```js

// 例1: 替代 apply方法调用函数
Math.max.apply(null, [14, 3, 77])  // ES5 的写法
Math.max(...[14, 3, 77])  // ES6 的写法, 等同于 Math.max(14, 3, 77)
```


S2 用于数组/对象
```js

// 例2: 浅拷贝数组
const a1 = [1, 2]

const a2 = [...a1]    // 方法1: 扩展运算符方法
const [...a2] = a1    // 方法2: 解构赋值 + 剩余参数法



// 例3: 合并数组
const arr1 = ['a', 'b'];
const arr2 = ['c'];
[...arr1, ...arr2]    // [ 'a', 'b', 'c' ]

```



## <span id="5"> 5 解构赋值 </span>

1 Q: 解构赋值 有哪些使用场景

A: S1 对象解构赋值 + 默认参数

```js
let node = {
  type: "Identifier"
}

let { type: localType, name: localName = "bar" } = node

console.log(localType)    // "Identifier"
console.log(localName)    // "bar"
```


S2 数组解构赋值
```js
// 例1: 获取特定index值
let colors = [ "red", "green", "blue" ]
let [ , , thirdColor ] = colors
console.log(thirdColor)            // "blue"


// 例2: 解构赋值 + 默认参数
let colors = [ "red" ]
let [ firstColor, secondColor = "green" ] = colors
console.log(firstColor)      // "red"
console.log(secondColor)    // "green"
```


S3 函数参数解构赋值 + 默认参数: 用以明确 对象参数的具体内容
```js
function setCookie(name, value, { secure, path, domain, expires } = {}) {
  // ...
}

// 例2
function setCookie(name, value, { secure = false, path = "/", domain = "example.com"} = {}) {
  // ...
}
```

