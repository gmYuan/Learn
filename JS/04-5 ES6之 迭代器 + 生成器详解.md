# ES6之 迭代器 + 生成器 详解

目录:

1 [预读文档](#1)

2 [迭代器](#2)

3 [生成器](#3)


## <span id="1"> 1 预读文档 </span>

1 [深入理解ES6](https://legacy.gitbook.com/book/oshotokill/understandinges6-simplified-chinese/details)

2 [Iterator 和 for...of 循环](http://es6.ruanyifeng.com/#docs/iterator)

阅读原因: 直接参考文档



## <span id="2"> 2 迭代器 </span>

1 Q: 什么是迭代器(Iterator), 有什么作用

A:

A1 迭代器: 具有next()方法的对象 + 内部的 next()又返回一个 具有value和done属性的 对象

A2 迭代器的作用是: 1. 为ES6所有可遍历对象提供一个统一的 访问数据方法;  2. 一定程度上弱化对for循环的使用依赖程度

用代码表示迭代器为:

```js
function createIterator(items) {
  let i = 0
  return {
    next() {
      let done = (i >= items.length ? true : false)
      let value = (done ? undefined : items[i++])
      return {
        value,
        done
      }
    }
  }
}

let iterator = createIterator([1, 2, 3])
console.log(iterator.next())          // "{ value: 1, done: false }"
console.log(iterator.next())         // "{ value: 2, done: false }"
console.log(iterator.next())         // "{ value: 3, done: false }"
console.log(iterator.next())        // "{ value: undefined, done: true }"
// 之后的所有调用
console.log(iterator.next())       // "{ value: undefined, done: true }"
```

2 Q: 什么是可迭代对象(Iterable), 它有什么特点

A: S1 在JS中, 如果一个对象A具有[symbol.itetaor]方法 + 该方法返回的是迭代器对象B, 那么对象A就是一个 可迭代对象

S2 可迭代对象的特点是: 可以通过`for...of语法` 访问其对象的内部数据

示例代码为:

```js
class RangeIterator {
  constructor(start, stop) {
    this.value = start;
    this.stop = stop;
  }

  [Symbol.iterator]() { return this; }      // new调用时,原型链上this指向实例对象 + 具有next()方法

  next() {
    var value = this.value;
    if (value < this.stop) {
      this.value++;
      return {done: false, value: value};
    }
    return {done: true, value: undefined};
  }
}

function range(start, stop) {
  return new RangeIterator(start, stop);
}


for (var value of range(0, 3)) {
  console.log(value);             // 0, 1, 2
}
```

3 Q: 有哪些语法操作会默认调用 迭代器next()方法

A: 解构赋值 / 扩展运算符 / for...of / Array.from() / yield* 等


## <span id="3"> 3 生成器 </span>

1 Q: 什么是生成器, 有什么作用

A: S1 生成器是 可以返回迭代器的特殊函数 + 内部使用yield表达式来 暂定并返回迭代器当前状态值


2 Q: yield表达式的作用是什么

A: S1 yield在 每次调用next时返回当前迭代器的状态值，状态值就是`yield A`中的 A；

S2 `yield A`语句默认返回的值是undefined, 可以通过next(C),把C赋值给 `上一个yield表达式的返回值`

S3 每次执行next(),都会在yield出暂停，再次执行时从暂停出再继续

代码举例:

```js
function* f() {
  for(var i = 0; true; i++) {
    var reset = yield i;
    if(reset) { i = -1; }
  }
}

var g = f();

g.next()       // { value: 0, done: false }
g.next()       // { value: 1, done: false }
g.next(true)  // { value: 0, done: false },  因为ture被赋值给 上一次的yiled表达式返回值了
```

3 Q: 如何理解 生成器的throw语句

A: S1 