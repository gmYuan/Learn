# 请求之 跨域方法

## 目录

1 [预读文档](#1)

2 [为什么要进行跨域- 同源策略](#2)

3 [跨域常用方法](#3)


## <span id="1">一 预读文档 </span>

1 阅读文档有

1 [九种跨域方式实现原理](https://juejin.im/post/5c23993de51d457b8c1f4ee1)

阅读原因: 同源策略+JSONP部分 直接参考文档

2 [正确面对跨域，别慌](https://juejin.im/post/5a2f92c65188253e2470f16d)

阅读原因: CORS部分 直接参考文档

3 [我知道的跨域与安全](https://juejin.im/post/5a6320d56fb9a01cb64ee191)

阅读原因: 与安全相关部分, 待读...


## <span id="2">三 跨域常用方法 </span>

1 Q: 如何实现跨域

方法1: JSONP

S1 原理是: script/img等标签的请求没有同源策略限制 + script标签内的JS语句会自动执行(类似于script中有alert语句的情况)

S2 JSONP的优点: 简单

S3 JSONP的缺点: 只支持get请求 + 需要前后端配合实现 + 存在安全性问题

前端部分的 具体实现

```js
function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {
    let script = document.createElement('script')  
    window[callback] = function(data) {     //S4  A执行 之前声明的回调函数，对返回的数据进行操作
      resolve(data)
      document.body.removeChild(script)
    }

    // S2 声明一个回调函数A，把A当做请求参数，传递给服务器
    params = { ...params, callback }   // S2 wd=b&callback=show  
    let arrs = []
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`)
    }
    script.src = `${url}?${arrs.join('&')}`  //S1 创建一个<script>标签，src为跨域地址
    document.body.appendChild(script)
  })
}

// 使用
jsonp({
  url: 'http://localhost:3000/say',
  params: { wd: 'Iloveyou' },
  callback: 'show'
}).then(data => {
  console.log(data)
})
```

方法2: CORS (跨域资源共享)

S1 HTTP请求分为 简单请求/非简单请求

S2.1 简单请求: 请求类型 get/post/head + Content-Type限于三个值(text/plain + application/x-www-form-urlencoded + multipart/form-data)

S2.2 简单请求: 浏览器A会自动在 请求头添加origin字段, 表明当前请求来源

S2.3 服务器B需要设置以下响应头以开启CORS: `Access-Control-Allow-Origin/ [Access-Control-Expose-Headers`等


S3.1 非简单请求: 请求类型 PUT/DELETE / Content-Type字段的类型是application/json

S3.2 非简单请求的CORS请求，会在正式通信之前，自动进行一次 "预检"请求

预检请求包含以下请求字段: `Origin / Access-Control-Request-Method / Access-Control-Request-Headers`

S3.3 复杂请求时, 后端需要设置以下字段: 
`Access-Control-Allow-Origin/ Access-Control-Allow-Methods / Access-Control-Allow-Headers` 


方法3: nginx反向代理

S1 原理是: A向 代理服务器B发送请求 + B向目标服务器C转发请求 + 服务器B和C之间无 同源限制

S2 通过nginx配置一个代理服务器 (域名与domain1相同，端口不同)做跳板机;

反向代理访问domain2接口，并且可以修改cookie中domain信息，方便当前域cookie写入，实现跨域登录
