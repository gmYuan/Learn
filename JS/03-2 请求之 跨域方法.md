# 请求之 跨域方法

## 目录

1 [预读文档](#1)

2 [为什么要进行跨域](#2)

3 [跨域常用方法](#3)


## <span id="1">一 预读文档 </span>

1 [可能是最好的跨域解决方案](https://juejin.im/post/5dc9228cf265da4d2125de8d#heading-0)

阅读原因: 同源策略直接参考文档


1 [九种跨域方式实现原理](https://juejin.im/post/5c23993de51d457b8c1f4ee1)

阅读原因: JSONP/ CORS部分/Nginx反向代理/postMessage/websocket 直接参考文档

2 [跨域要不要了解下 CORS 基础篇](https://juejin.im/post/5c0a55e76fb9a049ef2665ba)

阅读原因:  CORS部分 直接参考文档2

3 [正确面对跨域，别慌](https://juejin.im/post/5a2f92c65188253e2470f16d#heading-19)

阅读原因:  Node中间件代理部分 直接参考文档


4 [我知道的跨域与安全](https://juejin.im/post/5a6320d56fb9a01cb64ee191)

阅读原因: 与安全相关部分, 待读...


## <span id="2">二 为什么要进行跨域 </span>

1 Q: 为什么要进行跨域

A: S1 由于浏览器的同源策略

S2 所谓同源策略，是指 浏览器规定, 请求源A和响应源B之间的 协议、域名、端口号必须完全一致，才可以进行正常通信;

如果请求A和响应B 之间 不同源,浏览器就会有以下 安全限制:

A1 A无法读取B的 存储性内容：如 cookie/localStorage/IndexDB

A2 A无法获取到B 的DOM节点

A3 B返回的AJAX请求响应会被 A的浏览器拦截


## <span id="3"> 三 跨域常用方法 </span>

1 Q: 如何实现跨域

方法1: JSONP

S1 原理是: script/img等 静态资源文件请求没有 同源策略限制 + 请求返回的响应是 合法的JS语句 + script标签内的JS语句会自动执行

S2 JSONP的优点: 简单, 兼容性好

S3 JSONP的缺点: 只支持get请求 + 需要前后端配合实现 + 存在安全性问题

前端部分的 具体实现

```js
// 使用
jsonp({
  url: 'http://localhost:3000/say',
  params: { wd: 'Iloveyou' },
  callback: 'show'
}).then(data => {
  console.log(data)
})


function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {

    params = {...params, callback}
    let arr = []
    for(let key in params) {
      arr.push(`${key}=${params[key]}`)   // S2 [wd=b, callback=show]
    }

    let script = document.createElement('script')   //S1 创建一个<script>标签，src为跨域地址
    script.src = `${url}?${arr.join('&')}`  // S3 ?wd=b&callback=show
    document.body.appendChild(script)

    window[callback] = function(data) {     //S4  A执行 之前声明的回调函数，对返回的数据进行操作
      resolve(data)
      document.body.removeChild(script)
    }

  })
}
```

方法2: CORS (跨域资源共享)

S1 CORS主要是由 服务器端设置一系列响应头，来解决跨域限制

S2 需要设置的响应头,主要有以下几种:

`Access-Control-Allow-Origin`: 设置 允许的 跨域源

`Access-Control-Allow-Headers`: 设置 允许的 跨域请求头

`Access-Control-Allow-Methods`: 设置 允许的 跨域请求方法

`Access-Control-Allow-Credentials`: 设置 是否允许携带cookie, 如果要携带cookie, 也需要请求端设置`xhr.withCredentials = true`

`Access-Control-Max-Age`: 设置 预检请求的存活时间


S3 预检请求和 请求分类有关。 请求分为 简单请求和复杂请求;

简单请求: 请求方法为get/post/head + contnet-type值为以下3种之一: application/x-www-urlencoded & multipart/form-data & text/plain

在发送复杂请求前, 浏览器会先发送一个方法为OPTION的预检请求, 以向服务器确定相关跨域信息。


方法3: Node中间件代理(正向代理)

S1 原理是: A向 代理服务器B发送请求 + B向目标服务器C转发请求 + 服务器B和C之间无 同源限制



方法4: nginx反向代理

S1 原理是: A向 代理服务器B发送请求 + B向任意某个服务器C转发请求(负载均衡)

```
server {
  # 监听80端口号
  listen 80;

  # 监听访问的域名
  server_name www.domain1.com;

  # 根据访问路径配置
  location / {
    # 反向代理
    proxy_pass   http://www.domain2.com:8080;

    # 修改cookie里域名
    proxy_cookie_domain  www.domain2.com  www.domain1.com;

    # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用

    # 当前端只跨域不带cookie时，可为*
    add_header Access-Control-Allow-Origin  http://www.domain1.com;  

    add_header Access-Control-Allow-Credentials  true;
  }

}
```


方法5: postMessage

```js

//发送数据
iframe.contentWindow.postMessage('A to B', 'http://b.com:4000')

//接受返回数据
window.onmessage = function(e) {
  console.log(e.data)   // B back to A
}


// b
window.onmessage = function(e) {
  console.log(e.data)   // A to B

  e.source.postMessage('B back to A', e.origin)
}

```


方法6: websocket

```js
<script>
  
// socket.html  

let socket = new WebSocket('ws://b.com:4000')

socket.onopen = function () {
  socket.send('A to B');      //向服务器发送数据
}

socket.onmessage = function (e) {
  console.log(e.data);      //接收服务器返回的数据
}


// server.js
let express = require('express');
let app = express();
let WebSocket = require('ws');  //安装ws

let wss = new WebSocket.Server( {port:3000} );

wss.on('connection', function(ws) {
  // B 向 A 返回信息
  ws.on('message', function (data) {
    console.log(data)
    ws.send('B back to A')
  })

})

</script>
```

