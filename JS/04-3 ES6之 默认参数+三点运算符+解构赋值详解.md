# ES6之 默认参数 + 三点运算符 + 解构赋值 详解

目录:

1 [预读文档](#1)

2 [默认参数](#2) 

3 [三点运算符...](#3)

4 [](#4)

5 [](#5)
 

## <span id="1"> 1 预读文档 </span>

1 [深入理解ES6](https://legacy.gitbook.com/book/oshotokill/understandinges6-simplified-chinese/details)

2 [函数的扩展](http://es6.ruanyifeng.com/#docs/function)

阅读原因: 全面介绍了默认参数知识点




## <span id="2"> 2 默认参数 </span>

1 Q: 默认参数有哪些使用场景

A: S1 用于函数:

```js
// 例1: 函数默认参数
function makeRequest(url, timeout = 2000, callback = function() {}) {
  // ......
  console.log(timeout)
  console.log(callback)
}


// 设置了默认值的参数 是可选传入的, 但如果是中间参数则不能省略 (timeout需要显式传入undefined)
makeRequest("/foo")
makeRequest("/foo", undefined)


// 例2: 函数默认参数 + arguments： arguments是 参数的拷贝副本，只与实参相关
function mixArgs(first, second="b") {
  console.log(arguments.length)
  console.log(first === arguments[0])
  console.log(second === arguments[1])

  first = "c"
  second = "d"
  console.log(first === arguments[0])
  console.log(second === arguments[1])
}
mixArgs("a");  //实际调用

// 输出结果
1       //arguments的值只有一个传入的实参 first=a
true
false  

false  // arguments对象不会随变化而改变，是其副本
false


// 例3: 每次函数调用时都会创建一个新的 默认参数对象
function append(value, array = []) {
  array.push(value);
  return array;
}

append(1);   //[1]
append(2);   //[2], not [1, 2]


// 例4: 参数默认值表达式
let value = 5

function getValue() {
  return value++
}

function add(first, second = getValue()) {
  return first + second
}

console.log(add(1, 1))    // 2
console.log(add(1))      // 6
console.log(add(1))      // 7
```


## <span id="3"> 3 三点运算符... </span>

1 Q: 三点运算符有哪些使用场景

A: S1 剩余参数(rest参数)

```js
// 例1: 使用示例
function add(...values) {
  let sum = 0
  values.reduce( (pre, cur) => {return sum = pre + cur})
  return sum
}

add(1, 2, 3) // 6
```












## <span id="4"> 4 this指向规则 </span>

1 Q: this指向对象 有哪些常见情况

A: S1 全局环境 + 非严格模式: this指向 window对象;  全局环境 + 严格模式: this指向 undefined

这种情况，可以理解成 `test.call(undefined)`

```js
this.b = 'test'
console.log(this.b === window.b)    //ture

function test(){
  console.log(this)
}
test()   //window
```

S2 函数作为对象方法调用: this指向 该对象

这种情况，可以理解成 `obj.getName.call(obj)`

```js
var obj = {
  name: 'klay',
  getName: function(){
    console.log(this.name)
  }
}
obj.getName()    //klay

```

特殊情况1: 函数作为嵌套对象 内部的方法调用: this指向 内部对象,  可以理解成 `obj1.obj2.getName.call(obj2)`

```js
function naming(){
  console.log(this.name)
}

var obj1 = {
  name:'klay',
  getName: naming,
  obj2:{
    name:'inner',
    getName: naming
  }
}

obj1.obj2.getName()    //inner
```

特殊情况2: 函数作为数组成员调用: this指向 该数组对象 (因为数组是特殊的对象)
```js
function fn1(){
  console.log(this)
}
var fn2,fn3

var arr = [fn1,fn2,fn3]
arr[0]()                 //arr
```

特殊情况3: 对象方法赋值给一个函数A，调用函数A时，this指向window
```js
var name = 'outer'
var obj1 = {
  name:'klay',
  getName: function(){
    console.log(this.name)
  }
}

var outer = obj1.getName
outer()                   //outer
```

特殊情况4: 对象方法和运算符（布尔/算数/赋值等）一起使用，this对象指向全局对象
```js
var obj = {
  foo: function(){
    console.log(this)
  }
}

(false || obj.foo)()    //window
(obj.foo, obj.foo)()    //window
(obj.foo = obj.foo)()   //window
```

特殊情况5: 对象里的函数A含有函数B，函数B执行时，B内部的this 指向window对象
```js
var obj1 = {
  f1: function(){
    console.log(this)
    var f2 = function(){
      console.log(this)
    }()
  }
}

obj1.f1()             //obj1   window
```

特殊情况6: 回调函数A中 传入的函数B内部使用this, this会被修改成 window对象/DOM元素等

类似的还有内置函数的回调，如`setTimeout()、foreach()、事件监听回调函数`等

```js
var a = 'global'
var obj1 = {
  a:2,
  foo(){
    console.log(this.a)
  }
}

function doFoo(fn){
  fn()
}

doFoo(obj1.foo)    //"global"
```

特殊情况7: 原型链和 getter/setter中的 this，都指向调用方法的对象（具体见MDN）


S3 函数调用时显式绑定指向对象(call/apply/bind): 此时this指向 传入的对象

```js
function foo(){
  console.log(this.a)
}

var obj1 = {
  a:2
}

var bar = function(){
  foo.call(obj1)
}

bar()              //2
bar.call(window)   //2  因为bar函数内部 已经手动固定指向了obj1对象, 不会再改变
```


S4 使用new创建对象实例时，this指向新创建的对象实例

```js
function Foo(a){
  this.a = a
}

var bar = new Foo(2)
console.log(bar.a)     //2
```

以上4种情况的优先级是: `new构造函数 > 显式调用 > 默认对象调用 > 全局（函数）调用`


S5 使用箭头函数，其this 就是  外层函数调用时的this指向对象

箭头函数没有this, 箭头函数的this值 `遵循词法作用域的查找规则（就像是一个普通变量）`

```js
function foo(){
  return ()=>{
    console.log(this.a)   
  }
}

var obj1 = {a:1};
var obj2 = {a:2};

var bar = foo.call(obj1)
bar.call(obj2)           //1,不是2!, 因为 箭头函数的this 继承自foo()第一次调用时的this指向对象
```


## <span id="5"> 5 箭头函数其他特点 </span>

1 Q: 箭头函数和 ES5函数有哪些不同点

A:
S1 箭头函数 没有this / super / arguments, 也没有new.target绑定, 所以这些值的查找规则 遵循词法作用域

S2 箭头函数不能使用new调用: 箭头函数没有 [[Construct]]方法，因此不能被用为构造函数, 使用new  调用箭头函数会报错

S3 箭头函数没有原型: 也就是没有prototype属性

S4 箭头函数不能更改this, 因此虽然可以使用call/apply/bind方法，但this值不会发生改变

S5 箭头函数 不允许重复的具名参数: 传统函数只有在严格模式下才禁止这种重复