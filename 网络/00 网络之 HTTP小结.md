# 网络之 HTTP小结

Q1: HTTP有哪些特点
A:
S1 它是灵活可扩展的，可以任意添加头字段 实现自定义功能

  - HTTP协议一开始只规定了报文的基本格式，报文的各个组成部分都没有严格的语法语义限制，可以由开发者任意定制
  - 所以在发展过程中，逐渐增加了 请求方法/ 版本号/ 状态码 /头字段等特性
  - body也不再限于 文本形式的 TXT/HTML，而是能够传输 图片/音频视频等任意数据
  - HTTP不限制具体的下层协议，它可以运行在 TCP/SSL/基于UDP的QUIC 上层


S2 可靠传输，基于 TCP/IP 协议 “尽量”保证数据的送达
  - 因为 HTTP协议是基于 TCP/IP 的，而 TCP是一个 “可靠”的传输协议，所以HTTP就继承了这个特性

  - 具体做法是 对实际传输的数据（entity）做一层包装，加上一个头，然后调用 Socket API，通过 TCP/IP 协议栈 发送或者接收

  - "可靠" 传输是指在 网络基本正常的情况下 数据收发必定成功，在 网络繁忙/ 连接质量差等恶劣的环境下，也有可能收发失败


S3  应用层协议，比 FTP/SSH等 更通用/功能更多
  - 只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求
  - 相比其他应用层协议，HTTP 的适用范围更广，应用广泛

S4 HTTP 协议使用的是 请求 - 应答 通信模式 
  - 请求 - 应答模式是 HTTP 协议最根本的通信模型
  - 请求 - 应答模式 也明确了 HTTP 协议里通信双方的定位，永远是请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作
  -  请求 - 应答模式 也导致了 WebService/ RESTful/ gPRC 等技术的出现


S5 HTTP 协议是无状态的，每个请求互相独立的，不要求客户端/服务器 记录请求信息
  - “状态”是指 客户端/服务器里保存的一些数据/标志，记录了 通信过程中的一些变化信息
  -  “无状态” 形象地来说就是 “没有记忆能力”

  - HTTP 在整个协议里 没有规定任何的“状态”，客户端和服务器永远是处在一种“ 无知 ”的状态。建立连接前两者互不知情，每次收发的报文也都是互相独立的，没有任何的联系。收发报文也不会对客户端或服务器产生任何影响，连接后也不会要求保存任何信息。

  - 但 HTTP 是“灵活可扩展”的，虽然标准里没有规定“状态”，但完全能够 在协议的框架里给它“打个补丁”，增加这个特性。
  
  - “无状态”的优点是：实现简单/ 减轻服务器负担/ 便于集群化负载均衡
  - “无状态”的缺点是：无法支持 有一系列的多个步骤的“事务”型操作


S6 HTTP是明文传输的，协议里的报文(header)不使用二进制数据，而是用可阅读的文本
  - 优点是 便于阅读和调试
  - 缺点是 传输内容不够安全：明文传输 + 无身份验证 + 无内容完整性校验

------
Q2 HTTP的双方如何 通信识别传输的数据类型
A:

S1 对于数据类型，HTTP使用了MIME规范的子集  (多用途互联网邮件扩展)
  - text：文本格式的可读数据，如 text/html、text/plain、text/css 等
  - image：图像文件，有 image/gif、image/jpeg、image/png 等
  - audio/video：音频和视频数据，如 audio/mpeg、video/mp4 等
  - application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释
，如application/json、application/javascript、application/pdf、application/octet-stream(未知类型，不透明的二进制数据)

S2 HTTP 在传输时为了节约带宽，有时候还会压缩数据
  - Encoding type 表明了 数据压缩的编码格式，这样对方才能正确解压缩，还原出原始的数据
  - 常用的有三种：
  - gzip：GNU zip 压缩格式
  - deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip
  - br：一种专门为 HTTP优化的 新压缩算法（Brotli）
有了 MIME type 和 Encoding type，通信双方可以识别和处理 body数据了


S3 客户端用 Accept头表明 希望接收的 数据类型 和 支持的编码格式
  - Accept: text/html,application/xml,image/webp,image/png
  - Accept-Encoding: gzip, deflate, br
  - 如果 请求报文里没有 Accept-Encoding字段，就表示客户端不支持压缩数据

S4 服务器用 Content头表明 实际发送的数据类型 和 编码格式
  - Content-Type: text/html
  - Content-Encoding: gzip
  - 如果 响应报文里没有 Content-Encoding字段，就表示响应数据没有被压缩

--------
Q3 HTTP如何传输大文件
A:

S1 数据压缩："Accept-Encoding " 请求头字段 + "Content-Encoding"响应字段
  - 压缩 通常只对文本文件有较好的压缩率
  - 图片、音频视频等 多媒体数据 已经是高度压缩的，用gzip处理也不会变小

S2 分块传输
  -  "Transfer-Encoding: chunked" 表示 响应报文里的body部分  不是一次性发过来的，而是分成了许多的 块(chunk)逐个发送
  -  "Transfer-Encoding: chunked" 的内容长度是未知的，因此和 "Content-Length" 响应字段互斥出现 

S2.2 分块传输的编码规则 采用了明文方式，具体见下：
  - 每个分块 包含两个部分，长度头和数据块；
  - 长度头 是以 CRLF(回车换行，即\r\n) 结尾的一行明文，用 16 进制数字表示长度
  - 数据块 紧跟在长度头后，最后 也用CRLF结尾，但数据不包含 CRLF
  - 最后用一个 长度为0的块 表示结束，即 "0\r\n\r\n"

具体示意图，见
![]()

S3 范围请求
  - 首先需要 服务端支持 局部范围请求内容 ==> 响应字段 "Accept-Ranges: bytes"
  - 客户端通知 想要获取的内容范围 ==> 请求字段 " range: bytes=x-y "

服务器收到 Range 字段后，需要做四件事：
  - 第一，检查范围是否合法，比如文件只有100个字节，但请求 "200-300"，这就是范围越界了。服务器会返回状态码416，意思是“你的范围请求有误，我无法处理，请再检查一下”。

  - 第二，如果范围正确，服务器就根据Range头 计算偏移量 + 读取文件片段了，之后返回状态码" 206 Partial Content "，表示body只是原数据的一部分

  - 第三，服务器添加一个响应头字段 "Content-Range: bytes x-y/length"，告诉片段的实际偏移量和资源的总大小

  - 最后发送数据，把片段用TCP发给客户端，这样一个范围请求就算是处理完成了。