# 网络之 HTTP2详解

### 目录

1 [预读文档](#1)

2 [HTTP2 相关](#2)


## <span id="1">一 预读文档 </span>

01 [解密HTTP/2与HTTP/3 的新特性](https://juejin.im/post/5d9abde7e51d4578110dc77f)

02 [HTTP2 详解](https://juejin.im/post/5b88a4f56fb9a01a0b31a67e#heading-60)

阅读原因: 直接 参考文档


## <span id="2">二 HTTP2 相关 </span>


Q1: HTTP1.1 存在哪些问题

A:

- S1 线头阻塞：TCP连接中 前面的请求未完成前，后续的请求都在排队等待

- S2 存在大量 冗余头部字段传输

- S3 采用文本格式 明文传输

- S4 只能客户端进行 主动请求


Q2: HTTP2有哪些改进点

A:

- S1 二进制分帧层: HTTP2采用`二进制格式`传输`数据帧`, 而不是1.x的文本格式

```
- A1 把原来的 "Header+Body"消息 "打散"为  数个二进制"帧"(Frame),

- A2 用"HEADERS"帧 存放头数据 + "DATA"帧 存放实体数据
```

![二进制图](https://user-gold-cdn.xitu.io/2019/2/28/16934b619431d975?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


- S2 多路复用: HTTP2让所有的通信都在一个TCP连接上完成，真正实现了 请求的并发

```
A1 HTTP2建立一个TCP连接，同域名下所有通信 都在单个连接上完成

A2 一个连接上面有任意多个流（stream），每个请求都当作一个流

A3 消息分割成一个/多个帧 在流里面乱序发送, 每帧的stream identifier标明这一帧属于哪个流 

A4 帧传输过去以后，根据 stream identifier进行重组，形成一个完整的请求或响应

A5 每个请求都可以带一个31bit的 优先值, 0表示最高优先级，数值越大优先级越低

多路复用可以只通过一个TCP连接，传输所有的请求数据
```

![多路复用图](https://user-gold-cdn.xitu.io/2019/2/27/1692fa29e41348f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- S3 头部压缩: 采用专门的 "HPACK"算法 压缩重复字段，每次请求只会发送 不同首部字段的值

```
A1 在客户端和服务器两端 建立"首部表"，来跟踪和存储 之前发送的键-值对

A2 对于相同的数据，请求和响应过程中 不再发送

A3 每个新的首部键-值对 要么被追加到当前表的末尾，要么替换表中之前的值

A4 还采用哈夫曼编码 来压缩整数和字符串，可以达到50%~90%的高压缩率
```

![首部压缩图](https://user-gold-cdn.xitu.io/2019/2/28/16934a8dc2cde720?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- S4 服务器端推送: 在浏览器请求HTML时, 可以提前把会用到的JS/CSS文件发给客户端，减少等待延迟

```
A1 客户端可以缓存 推送的资源 (发送 PUSH_PROMISE帧)

A2 客户端可以拒收 推送过来的资源 (发送 RST_STREAM帧)

A3 推送资源可以由 不同页面共享

A4 主动推送也遵守 同源策略

```


- S5 流量控制: 每个 http2流 都拥有自己的流量窗口，它可以限制另一端 发送数据