
## 前言

最近学习了JS事件的相关知识，所以对其做一下小结

这篇是关于事件模型的知识点

目录:

1 [事件及事件流](#1)

2 [事件处理程序](#2)
  
  - [HTML 的 on- 属性](#2.1)

  - [元素节点的 事件属性](#2.2)

  - [EventTarget.addEventListener()](#2.3)

3 [this 的指向](#3)

4 [事件委托](#4)


## <span id="1"> 一 事件及事件流 </span>

1 事件含义

S1 事件可以理解为 用户/浏览器 自身执行的 某种动作

S2 比如，点击按钮、提交表单、加载页面等 都是事件


2 事件流含义

含义: 页面中节点 接收事件 的顺序

> 想象 一张纸上有一组同心圆，如果把手指放在圆心上，那么手指指向的不是一个圆，而是纸上的所有圆

> 同理，如果用户单击了某个按钮，那么单击事件不仅仅发生在按钮上
> 在单击按钮的同时，同时单击了按钮的容器元素，甚至可以看作是 单击了整个页面


3 事件流类型

S1 事件捕获: 由外至内，触发顺序是 从不太具体的节点(document)，向下传播到最具体的节点(div)

S2 事件冒泡: 由内至外，即事件由最具体的元素(div)接收，然后逐级 向上传播到不具体的节点（document）


4 DOM事件流

S1“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段

S2 一个事件发生后，会在子元素和父元素之间传播（propagation）,这种传播分成三个阶段:

> 第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）

> 第二阶段：在目标节点上触发，称为“目标阶段”（target phase）

> 第三阶段：从目标节点传导回window对象（底层传回上层），称为“冒泡阶段”（bubbling phase）

> 这种三阶段的传播模型，使得同一个事件会在多个节点上触发

可见下图
[!事件流模型图](https://user-images.githubusercontent.com/25027560/38007715-4cc457d0-327d-11e8-9fb3-667fa75fc38c.png)

举例见下:

```js
   
<div>
  <p>点击</p>
</div>


// 设置触发阶段 + 回调函数
var phases = {
  1: 'capture',
  2: 'target',
  3: 'bubble'
}

var div = document.querySelector('div');
var p = document.querySelector('p');

div.addEventListener('click', callback, true)
p.addEventListener('click', callback, true)

div.addEventListener('click', callback, false)   // addEventListener方法第三个参数的不同，会导致绑定两个监听函数
p.addEventListener('click', callback, false)     // 同上

function callback(event) {
  var tag = event.currentTarget.tagName;
  var phase = phases[event.eventPhase];
  console.log("Tag: '" + tag + "'. EventPhase: '" + phase + "'");
}

// 点击输出的结果, click事件被触发了四次

// Tag: 'DIV'. EventPhase: 'capture'
// Tag: 'P'. EventPhase: 'target'
// Tag: 'P'. EventPhase: 'target'
// Tag: 'DIV'. EventPhase: 'bubble'

```

## <span id="2"> 二 事件处理程序 </span>

1 事件处理程序 含义

S1 触发事件后，浏览器监听到事件触发后，就会 自动执行/响应的 对应动作(函数)

S2 JavaScript 有三种方法，可以为事件绑定监听函数


### <span id="2.1"> 2.1 HTML的 on- 属性 </span>

1 HTML允许在元素的属性中，直接定义某些事件的回调函数

2 特点，见下示例

```js

// 例1
<div onclick="console.log('触发事件')">    // 2.S1 元素的事件监听属性，都是on加上事件

// 例2
<body onload="doSomething()">             // 2.S2 属性的值是将会执行的代码，而不是一个函数
<body onload="doSomething">               //      将会报错    


// 例3
<div onClick="console.log(2)">           	 // 2.S3 用这个方法指定的回调函数，只会在冒泡阶段触发
  <button onClick="console.log(1)">点击</button>      // 输出顺序为 1,2
</div>


// 例4
el.setAttribute('onclick', 'doSomething()')    // 2.S4 等同于 <Element onclick="doSomething()">


// 例5       
<input type="button" value="Click Me" onclick="alert(event.type)">  //2.S5 会自动传入 event事件对象 给回调函数


// 例6
<input type="button" value="Click Me" onclick="alert(this.value)">  //2.S6 this指向 事件的目标元素 

// 输出 "Click Me" 
```

3 缺点: 触发事件时，回调函数可能还未加载完成和执行(当回调函数被定义在页面最底部时) + html和JS代码 过度耦合 


### <span id="2.2"> 2.2 元素节点的 事件属性 </span>

1 每个元素（包括 window 和 document）都有自己的事件处理程序属性,

  将属性的值设置为一个函数，就可以指定 事件处理程序，语法形式见例1


2 注意点，见下示例

```js

// 例1
div.onclick = function (event) {
  console.log('触发事件');
}

例2
window.onload = doSomething;    // 2.S1 HTML的on-属性，它的值是函数执行结果，而DOM0级 只需函数声明

                                // 2.S2 使用这个方法指定的监听函数，也是只会在冒泡阶段触发 + this指向当前元素

```

3 删除方法: `xxx.onclick = null`

4 缺点: 同一个事件只能定义一个回调函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次


### <span id="2.3"> 2.3 EventTarget.addEventListener() </span>

1 addEventListener方法的详细介绍，参见 `EventTarget章节`

2 优点

S1 同一个事件可以添加多个监听函数

```js
var btn = document.getElementById("myBtn")

btn.addEventListener("click", function(){
  alert(this.id);
}, false)

btn.addEventListener("click", function(){
  alert("Hello world!");
}, false)

// 输出结果为 "myBtn" ,之后会显示 "Hello world!"

```

S2 能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数


3 删除方法: `xxx.removeEventListener()`,具体同样见 `EventTarget章节`


## <span id="3"> 三 this的指向 </span>

1 所有事件的回调函数，其内部this都指向 注册事件回调的 节点元素对象


2 在事件处理程序内部，`this值= event.currentTarget`,指向注册事件回调的元素;
  
  而`event.target`则指向当前阶段 实际真正触发事件的元素 (它有可能 未注册回调函数)


```js

//例1
var btn = document.getElementById("myBtn")
btn.onclick = function(event){
  alert(event.currentTarget === this); //true
  alert(event.target === this);        //true， 由于click事件的目标是按钮，因此这三个值是相等的
}

//例2
document.body.onclick = function(event){
  alert(event.currentTarget === document.body)  //true
  alert(this === document.body);                //true，因为事件处理程序 是注册到这个元素上的

  alert(event.target === document.getElementById("myBtn"));
      // true，target元素等于按钮元素，因为它是click事件真正的目标
      // 由于按钮上并没有注册事件处理程序，click 事件就冒泡到了document.body ，在那里事件才得到了处理
}
```

## <span id="4"> 四 事件委托 </span>

1 含义

S1 事件会在冒泡阶段向上传播到父节点

S2 因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件

这种方法叫做事件的代理（delegation）/ 事件委托

S3 事件委托 利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件


```js
// 例1
<ul id="myLinks">
  <li id="goSomewhere">Go somewhere</li>
  <li id="doSomething">Do something</li>
  <li id="sayHi">Say hi</li>
</ul>

// 传统方法
var item1 = document.getElementById("goSomewhere");
var item2 = document.getElementById("doSomething");
var item3 = document.getElementById("sayHi");

EventUtil.addHandler(item1, "click", function(event){
  location.href = "http://www.wrox.com";
})

EventUtil.addHandler(item2, "click", function(event){
  document.title = "I changed the document's title";
})

EventUtil.addHandler(item3, "click", function(event){
  alert("hi");
})

// 事件委托方法，只为 ul元素添加了一个 onclick事件处理程序
var list = document.getElementById("myLinks")

EventUtil.addHandler(list, "click", function(event){
  event = EventUtil.getEvent(event);
  var target = EventUtil.getTarget(event);
  switch(target.id){
    case "doSomething":
      document.title = "I changed the document's title";
      break

    case "goSomewhere":
      location.href = "http://www.wrox.com";
      break;

    case "sayHi":
      alert("hi");
      break
   }
})
```

2 优点

S1 只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个子节点上定义监听函数，占用的内存更少

S2 动态的添加DOM元素，不需要因为元素的改动 而修改事件绑定

S3 document对象很快就可以访问，可以在页面生命周期的任何时点上为它添加事件处理程序


3 注意点

S1 如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法

```js

// 例1  事件传播到 p 元素后，就不再向下传播了
p.addEventListener('click', function (event) {
  event.stopPropagation();
}, true)

// 事件冒泡到 p 元素后，就不再向上冒泡了
p.addEventListener('click', function (event) {
  event.stopPropagation();
}, false)

```

S2 stopPropagation方法只会阻止事件的传播，不会阻止该事件 触发<p>节点的其他click事件的监听函数

stopPropagation方法只能阻止这个事件的传播，不能取消这个事件

```js

// 例2

p.addEventListener('click', function (event) {
  event.stopPropagation()
  console.log(1)
});

p.addEventListener('click', function(event) {
  // 会触发
  console.log(2);
});

```

S3 如果想要彻底取消该事件，不再触发后面所有click的监听函数，可以使用stopImmediatePropagation方法

```js

// 例3

p.addEventListener('click', function (event) {
  event.stopImmediatePropagation();
  console.log(1);
});

p.addEventListener('click', function(event) {
  // 不会被触发
  console.log(2)
})

```

以上内容可参考

[01 JS高级程序设计 13.1~13.2 & 13.5.1](https://book.douban.com/subject/10546125/)

[02 阮一峰教程— 事件模型](http://javascript.ruanyifeng.com/dom/event.html)

[03 事件绑定、事件监听、事件委托](http://blog.xieliqun.com/2016/08/12/event-delegate/#)












