# 作用域之 执行上下文(栈)

目录:

1 [预读文档](#1)

2 [执行上下文(栈)](#1)

3 [执行上下文- 变量对象](#3)

4 [执行上下文- 作用域链](#4)

5 [综合示例](#5)



## <span id="1"> 1 预读文档 </span>

1 [中高级前端面试](#1)

阅读原因: 提纲挈领，参考回答 简明重点



## <span id="2"> 2 执行上下文(栈) </span>

1 Q: 什么是执行上下文

A:

S1 JS在执行 全局代码/函数代码/eval 这3种代码段时，就会形成一个执行上下文

S2 每个执行上下文都是一个对象，内部有3个属性: 变量对象、作用域链、this

S3 每个执行上下文，决定了 这段程序中 可以访问哪些数据，以及数据的值是什么


S4 当有多个执行上下文对象时，JS通过执行上下文栈 来管理多个上下文对象

S5 当函数内 所有代码执行完毕后，会销毁该执行上下文

S6 栈的特点是 后进先出


代码举例:

```js
function fn2(){
  console.log('fn2调用了')
}

function fn1(){
  fn2()
}

fn1()


// 用一个数组来表示执行上下文栈 ECStack = []

// 全局代码会形成一个全局上下文栈: ECStack = [globalContext]

// 调用fn1时，fn1执行上文环境会入栈: ECStack = [globalContent, fn1Context]

// fn1又调用了fn2,同理则 ECStack = [globalContent, fn1Context, fn2Content]


// fn2执行完毕后销毁出栈，即 ECStack.pop(), ECStack = [globalContent, fn1Context]

// fn1执行完毕后销毁出栈，即 ECStack.pop(), ECStack = [globalContent]

// JS继续执行以后代码...
```


## <span id="3"> 3 执行上下文- 变量对象 </span>

1 Q: 什么是变量对象(VO)

A: 

S1 变量对象 是记录该上下文中 所有变量声明和函数声明的 对象

S2.1 在全局上下文中，变量对象就是 全局对象window

S2.2 注意，全局上下文的VO中，没有arguments对象


S3 在函数上下文中，用活动对象(activation object, AO) 表示  变量对象（VO）

> (1)本质上，两者是一个东西：变量对象是抽象概念，活动对象是实际实现

> (2)在函数执行时，AO = VO + function parameters(函数形参) + arguments



2 Q: 变量对象的 具体执行过程

A: 

S1 函数代码执行时，会有一个准备阶段

S1.2 此时 AO 会以函数的arguments对象来初始化，arguments内保存了函数被调用时的实参

S1.3 AO 保存函数fn的所有形参作为key，值为传入的实参值

S3.4 AO 保存函数fn 内部的所有函数声明，值为函数声明对象，如果已存在相同名称的属性，则替换这个属性

S3.5 AO 保存函数fn 内部的所有变量声明，值为undefined，若变量名称 跟已声明的形参/函数相同，则忽略后者声明


S2 进入函数代码的执行阶段

S2.1 赋值形参值，值为传入的实参

S2.2 赋值函数值，值为 函数声明对象

S2.3 赋值变量值，值为 实际的变量赋值


实例见下

```js
function foo(a){
  var b = 2
  function c(){}
  var d = function(){}
  var c = 3
  b = 4
}

foo(1)

/*过程分析

S1 调用函数，创建执行上下文 + AO，fooContext = {AO:{} }

S2 进入准备阶段

fooContext = {
  AO: {
    arguments: {  
      0: 1,
      length: 1  
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},   // 之后的同名变量声明 不会影响已有的函数声明
    d: undefined            // 注意区分函数声明 和 函数表达式

  } 
}

S3 进入函数代码执行阶段

fooContext = {
  AO: {
    arguments: {  
      0: 1,
      length: 1  
    },
    a: 1,
    b: 4,
    c: reference to function c(){},  
    d: reference to FunctionExpression "d"

  } 
}
*/

```


## <span id="4"> 4 执行上下文- 作用域链 </span>

1 Q: 什么是作用域链

A: 多个执行上下文 变量对象的逐层引用

S1 函数在`被定义`时，就会创建一个内部属性[[scope]]，值是 它的所有外层函数的变量对象的 数组

S2 当该函数执行时，就会把当前的变量对象AO, 添加到[[scope]]数组的顶部，形成完整的作用域链

S3 作用域链的作用是 明确变量值的 查找范围


代码举例:

```js
var global = 'global scope'

function innerscope(){
  var inner = 'inner scope'
  return inner
}

innerscope()

/*
过程分析如下

S4.1 执行全局代码，则 ECStack = [globalContent]

S4.2 innerscope函数定义时，则 innerscope.[[scope]] = [globalContent.VO]

S4.3 innerscope函数执行时，则 ECstack = [innerscopeContext, globalContent]

S4.4 进入执行准备阶段，复制[[scope属性]]，则 innerscopeContent.Scope =  innerscope.[[scope]]

S4.5 创建innerscope.AO，初始化相关变量值

S4.6 把innerscope.AO推入到[[scope]]最前端，则 innerscopeContent.Scope = [AO, [[Scope]]]

所以innerscopeContext = { AO: {...}, Scope = [....] }

S4.7 进入函数代码 真正执行，赋值AO

S4.8 innerscope代码执行完后，销毁出栈，则 ECStack = [globalContent]

*/
```


## <span id="5"> 5 综合示例 </span>

1 Q: 分析以下代码的执行过程

```js
let nAdd
let t = () => {
    let n = 99
    nAdd = () => {
        n++
    }
    let t2 = () => {
        console.log(n)
    }
    return t2
};

let a1 = t()
let a2 = t()

nAdd()
a1()    
a2()    
```

A: S0 每次调用函数，就会新创建一个全局上下文。即使是调用的相同函数，形成的上下文也不同

S1 a1调用t函数，形成a1Context + a2调用t函数，形成a2Context

S2 a1Content = {AO: {n: 99, nAdd: fn1匿名函数, t2: fn2匿名函数}, Scope = [AO, [[scope]] ]}

S3.1 a2Content = {AO: {n: 99, nAdd: fn3匿名函数, t2: fn4匿名函数}, Scope = [AO, [[scope]] ]}

S3.2 此时，全局变量nAdd = fn3匿名函数

S4 执行nAdd()函数，a2Content里的n+1 =100, 而a1a2Content里的n不受影响(全局变量nAdd的指向被a2改写了)

S5 所以，输出的n值 分别是99、100

