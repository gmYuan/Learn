# 模块化之 模块化方式 

目录:

1 [预读文档](#1)

2 [什么是模块](#2)

3 [无规范模块](#3)

4 [CommonJS规范](#4)

5 [AMD规范](#5)

6 [CMD规范](#6)

7 [ES6规范](#7)



## <span id="1">1 预读文档 </span>

1 [前端模块化详解](https://github.com/ljianshu/Blog/issues/48)

阅读原因: 前端模块化的发展介绍，知识点很全面


## <span id="2"> 2 什么是模块 </span>

1 Q: 什么是模块

A: 

S1 一个大功能的实现 可能需要多个子功能互相配合，一个子功能就可以看作是一个模块

S2 每个模块内部的 数据/方法是私有的，模块之间只能通过暴露出的接口访问特定内容

S3 模块化的好处是: 减少全局变量，避免命名冲突 + 便于按需加载 + 保证数据私有


## <span id="3"> 3 无规范模块 </span>

1 Q: 在规范出现之前，是如何实现模块化的

A:

S1 全局function模式: 污染全局命名空间，容易引起命名冲突 + 模块之间无法直观知道是否依赖

```js
fucntion module1(){
  ...
}

function module2(){
  ...
}

```

S2 命名空间模式—简单对象封装: 减少了全局变量 + 外部仍然可以改变模块内部数据

```js

let module1 = {
  name: 'klay',
  sayHi(){
    console.log("Hi")
  }
}


// 外部改变内部数据
module.name = "klay2"
module.name     // "klay2"
```

S3 IIFE+闭包: 减少全局变量+内部数据私有，但是 未引入依赖模块

```js
(function(window){
  let name = "innername"

  function foo(){
    console.log(name)
  }

  function bar(){....}


  // 暴露模块
  window.module1 = {
    foo,     //ES6语法，相当于 foo:foo
    bar
  }
})(window)

```

S4 IIFE+闭包+依赖参数: 可以引入依赖，缺点是会发送多个script请求 + 引入依赖顺序必须正确

```js
(function(window, $){    //引入依赖jQuery
  let name = "inner1"
  function foo(){...}
  function bar(){...}
  window.module1 = {
    foo,
    bar
  }  

})(window,jQuery)

```


## <span id="4"> 4 CommonJS规范 </span>

1 Q: CommonJS规范 的特点是什么

A:

S1 具有模块作用域，不会污染全局作用域

S2 模块可多次加载，但是只会在第一次加载时运行一次,以后再加载，就直接读取缓存结果
    
S3 模块加载的顺序，按照其在代码中出现的顺序

S4 在服务器端，模块是在运行时同步加载的; 在浏览器端，模块需要提前编译打包处理

S5 CommonJS模块的加载机制是，输入的是被输出的值的拷贝,互不影响


2 Q: CommonJS规范 的语法是什么

A:

S1 导出模块: module.exports = value / exports.xxx = value


S2 引入模块: require(xxx), 如果是第三方模块，xxx为模块名；如果是自定义模块, xxx为模块文件路径
 
S3.1 CommonJS规范规定，每个模块内部，module变量代表当前模块, 是一个对象

S3.2 它的exports属性是对外的接口,加载某个模块，就是加载该模块的module.exports属性

S4 require命令的作用是，读入并执行一个JavaScript文件，然后返回该模块的exports对象



## <span id="5"> 5 AMD规范 </span>

1 Q: AMD规范 的特点是什么

A:

S1 AMD规范是非同步加载模块，允许指定回调函数,在浏览器环境更加适用


2 Q: AMD规范 的语法是什么

A:

S1 定义模块: 

```js

// 定义没有依赖的模块
define(function(){
   return 模块
})


// 定义有依赖的模块
define(['module1', 'module2'], function(m1, m2){
   return 模块
})

```

S2 引入模块: 

```js

require(['module1', 'module2'], function(m1, m2){
   使用m1/m2
})

```


## <span id="6"> 6 CMD规范 </span>

1 Q: CMD规范 的特点是什么

A:

S1 专门用于浏览器端

S2 模块使用时 才会异步加载执行

S3 CMD规范整合了CommonJS和AMD规范的特点


2 Q: CMD规范 的语法是什么

A:

S1 定义模块: 

```js

// 定义没有依赖的模块

define(function(require, exports, module){
 
  exports.xxx = value
  
  module.exports = value


})


// 定义有依赖的模块

define(function(require, exports, module){
  
  // 引入依赖模块(同步)
  
  var module2 = require('./module2')
  

  //引入依赖模块(异步)
    
  require.async('./module3', function (m3){
...})
  

  //暴露模块
  
  exports.xxx = value


})


```

S2 引入模块: 

```js
define(function (require) {
  var m1 = require('./module1')
  var m4 = require('./module4')

  m1.show()
  m4.show()
})
```


## <span id="7"> 7 ES6规范 </span>

1 Q: ES6规范 的特点是什么

A:

S1 CommonJS 模块输出的是 值的拷贝，ES6 模块输出的是 值的引用

S2 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口

S3 CommonJS 模块是同步导入，ES6 模块是异步导入


2 Q: ES6规范 的语法是什么

A:

S1 定义模块: 

```js
/** 定义模块 math.js **/

var basicNum = 0
var add = function (a, b) {
    return a + b
}

export { basicNum, add }

```

S2 引用模块: 

```js
import { basicNum, add } from './math'

function test(ele) {
    ele.textContent = add(99 + basicNum);
}
```
