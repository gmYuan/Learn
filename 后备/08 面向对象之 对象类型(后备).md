# 面向对象之 对象类型

## 前言

最近学习了 JS的对象相关知识，所以做一下小结


目录

1 [对象本质](#1)

2 [对象的属性和特性](#2)

3 [对象语法](#3)
 
  - [键名相关](#3.1)
 
  - [属性的读取](#3.2)

  - [属性的删除](#3.3)

  - [属性的存在](#3.4)

  - [属性的遍历](#3.5)

4 [with语句](#4)
 

## <span id="1">一  对象本质</span>

1 对象的本质是: key-value对的 集合 /  `属性的集合(方法是属性值为函数的 特殊属性)`
  在内存中用heap表示

2 函数的类型也是对象，所以它也是属性的集合，可以为它增加属性，即:
  JQuery中的$就是一个函数

```js
var fn = function () {
  alert(100)
}

fn.a = 10
fn.b = function() {
  alert(123)
}
fn.c = {
  name: "klay",
  year: 2018
}


fn.b()  // 123
```

## <span id="2"> 二 对象的属性和特性 </span>

1 从上文可知，对象就是一个个 无序属性 的集合，但是，即使是在同一个对象里，它里面的属性之间却也可能有很大的差异性

比如: 有些属性值我们是可以改变的，有些却不可以（甚至都无法删除），这是为什么？


2 首先 要明确对象在内存中的存储方式:

S1 变量名: 值（变量值是 基本类型） / 内存地址addr（变量值是 引用类型）

S2 引用类型（key-value对）是以字典形式存储的，属性名: 属性值对象（称为属性描述对象）

   换言之，整个属性是用一个对象A表示的，里面属性值也是用一个对象B表示的


S3 举例，`var example =  {foo: 5} ,  example.foo` 的访问过程是:

```html
查找到example标识符—> 变量值是引用类型，所以指向 一个内存地址addr1—>

在addr1里查找到一个对象X —>  X里查找到一个标识符foo—>  foo又指向一个对象Y

在对象 Y里有一个[[value]]特性——> [[value]]存储的值是5—> 输出example.foo = 5

```

还不清楚的 可参考阮一峰的 文章:

[JavaScript 的 this 原理]( http://www.ruanyifeng.com/blog/2018/06/javascript-this.html)


3 由上2可知，对象中的属性名，指向的属性值都是一个 属性描述对象，

  这个属性描述对象里也有一些属性，为了和“外层属性”区别，高程里称其为 特性

  所以，就是特性决定了对象里属性的表现（是否可访问、可枚举等）

4 根据所含特性的不同，可以把对象中的属性分为两种:  数据属性和访问器属性

数据属性

  含有 `[[ configurable]]、[[enumerable]]、[[writable]]、[[value]]特性`的属性，称为 数据属性

访问器属性

  含有 `[[ configurable]]、[[enumerable]]、[[get]]、[[set]]特性`的属性，称为 访问器属性


关于这6种特性的具体含义，可参考高程P138~144，或者阮一峰的教程:

[属性描述对象]( https://javascript.ruanyifeng.com/stdlib/attributes.html)

5 因为特性是用来让JS引擎描述属性行为的，所以我们无法直接访问和修改特性，但是，

  可以用ES5提供的 `Obdect.defineProperty()` 和 `Object.defineProperties()` 设置对象的属性和属性特性

  可以通过 `Object.getOwnPropertyDescriptor()` 获取属性描述对象


## <span id="3">三 对象语法</span>

### <span id="3.1">3.1 键名相关</span>

1 对象的所有键名都是字符串，如果键名是数值，会被自动转为字符串

```js
var obj = {
  1: 'a',
  3.2: 'b',
  1e2: true,
  1e-2: true,
  .234: true,
  0xFF: true
};

obj 
// Object {
//   1: "a",
//   3.2: "b",
//   100: true,     //看上去像数值，实际上都被自动转成了字符串
//   0.01: true,
//   0.234: true,
//   255: true
// }

obj['100']    // true
```

2 如果键名不符合标识名的条件，且也不是数字，则必须加上引号，否则会报错

// 报错
var obj = {
  1p: 'Hello World'
};

// 不报错
var obj = {
  '1p': 'Hello World',
  'h w': 'Hello World',
  'p+q': 'Hello World'
}
```

3 如果属性的值还是一个对象，就可以形成链式引用

```
var o1 = {};
var o2 = { bar: 'hello' };

o1.foo = o2   // 对象o1的属性foo指向对象o2，就可以链式引用o2的属性
o1.foo.bar   // "hello"
```

### <span id="3.2">3.2 属性的读取</span>

1 读取对象属性的方法: 一种是使用点运算符，还有一种是使用方括号运算符

2 注意点

S1 使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理

S2 方括号运算符内部 还可以使用表达式

S3 数值键名不能使用点运算符（会被当成小数点），只能使用方括号运算符

```js
var obj = {
  p: 'Hello World'
}

obj.p      // "Hello World"
obj['p']   // "Hello World"  


// 例2
var foo = 'bar'

var obj = {
  foo: 1,
  bar: 2
}

obj.foo   // 1    使用点运算符，foo就是字符串
obj[foo]  // 2.S1    使用方括号运算符 + 不使用引号，那么foo就是一个变量，指向字符串bar


// 例3
obj['hello' + ' world']
obj[3 + 3]             // 2.S2 可以使用表达式 + 数字键可以不加引号，因为会自动转成字符串


// 例4
var obj = {
  123: 'hello world'
}

obj.123     // 2.S3 报错  数值键名不能使用点运算符
obj[123]   // "hello world"

```

3 查看一个对象本身的所有属性，可以使用Object.keys方法

```js
var obj = {
  key1: 1,
  key2: 2
}

Object.keys(obj)  // ['key1', 'key2']
```

### <span id="3.3">3.3 属性的删除：delete命令</span>

1 delete用于 删除对象的属性，删除成功后返回true

```js
var obj = { p: 1 }
Object.keys(obj)    // ["p"]

delete obj.p        // true
obj.p               // undefined
Object.keys(obj)    // []
```

2 删除一个不存在的属性，delete不报错，而且返回true

因此，不能根据delete命令的结果，就认定某个属性是存在的

```js
var obj = {}
delete obj.p     // true
```

3 当属性存在且不得删除时，delete命令会返回false

```js
var obj = Object.defineProperty({}, 'p', {
  value: 123,
  configurable: false
})

obj.p         // 123
delete obj.p  // false
```
4 delete命令只能删除对象本身的属性，无法删除继承的属性

这说明，即使delete返回true，该属性依然可能读取到值 (当这个属性是继承所得时)

```js
var obj = {}

delete obj.toString  // true
obj.toString         // function toString() { [native code] }
```


### <span id="3.4">3.4 属性的存在</span>

1 in运算符用于检查对象是否包含某个属性（检查的是键名，不是键值），如果包含就返回true，否则返回false

```js
var obj = { p: 1 }

'p' in obj           // true  左边是一个字符串，表示属性名，右边是一个对象
'toString' in obj    // true  in运算符的问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的
```

2 可以使用对象的hasOwnProperty方法判断，是否为对象自身的属性

```js
var obj = {}
if ('toString' in obj) {
  console.log(obj.hasOwnProperty('toString'))   // false
}
```

### <span id="3.5">3.5 属性的遍历</span>

1 for...in循环用来遍历一个对象的全部属性

```js
var obj = {a: 1, b: 2, c: 3};

for (var i in obj) {
  console.log('键名：', i);
  console.log('键值：', obj[i]);
}
// 键名： a    键值： 1
// 键名： b    键值： 2
// 键名： c    键值： 3
```
2 注意点
    
S1 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性

S2 它不仅遍历对象自身的属性，还遍历继承的属性，

所以使用for...in的时候，可结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性

```js
var person = { name: '老张' };

for (var key in person) {
  if (person.hasOwnProperty(key)) {
    console.log(key);
  }
}

// name
```

## <span id="4">四  with 语句</span>

1 语法

```
with (对象) {
  语句
}
```

2 作用: 操作同一个对象的多个属性时，提供一些书写的方便

```js

// 例一
var obj = {
  p1: 1,
  p2: 2,
}

with (obj) {
  p1 = 4
  p2 = 5
}

// 等同于
obj.p1 = 4;
obj.p2 = 5;
```

```js
// 例二
with (document.links[0]){
  console.log(href);
  console.log(title);
  console.log(style);
}
// 等同于
console.log(document.links[0].href);
console.log(document.links[0].title);
console.log(document.links[0].style);
```

3 如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量

这造成了with语句的一个很大的缺点: 绑定对象不明确


```js
var obj = {}
with (obj) {
  p1 = 4;
  p2 = 5;
}

obj.p1   // undefined
p1       // 4    创造了一个全局变量p1
```

4 建议不要使用with语句，可以用一个临时变量代替with

```js
with(obj1.obj2.obj3) {
  console.log(p1 + p2)
}

// 可以写成
var temp = obj1.obj2.obj3;
console.log(temp.p1 + temp.p2)
```

以上可参考

[01 王福朋博客系列1— 一切都是对象](http://www.cnblogs.com/wangfupeng1988/p/3977987.html)

[02 阮一峰教程— 数据类型-对象](https://wangdoc.com/javascript/types/object.html)


  
