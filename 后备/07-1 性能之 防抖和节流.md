# 性能之 防抖和节流


目录:

1 [预读文档](#1)

2 [防抖含义及实现](#2)

3 [节流含义及实现](#3)



## <span id="1">1 预读文档 </span>

1 [JS专题之 跟着underscore学防抖](https://github.com/mqyqingfeng/Blog/issues/22)

2 [JS专题之 跟着underscore学节流](https://github.com/mqyqingfeng/Blog/issues/26)

阅读原因: 伢羽系列博客，可读性很好



## <span id="2"> 2 防抖含义及实现 </span>

1 Q: 什么是 防抖

A:

S1 防抖: 在事件触发 N秒后才执行 回调函数，如果在这段时间中再次触发事件，则重新计时

S2 效果类似于法师大招读条，如果读条过程中再次释放，就重新开始读条



2 Q: 实现防抖的逻辑步骤 是什么

A:

S1 在事件触发N秒后，才执行回调: 

S1.1 执行回调函数— 把回调和延迟时间N，作为参数传入

S1.2 延迟调用效果— setTimeout()延时


S2 N时间内再次触发事件，则清除回调+重新计时:

S2.1 N内 再次触发事件— 2次调用的时间差和N进行比较，这是 节流的思路

S2.2 N内 再次触发事件— 内部闭包 + 无脑清除timer,这是 防抖的思路

因为当满足N后再清除，则已经添加到消息队列了 + 不满足N清除则最好


S3.1 清除回调— clearTimeout(timer), 注意timer为undefined也不会报错

S3.2 重新计时— 重新调用timer


S4.1 修复延时函数中，回调丢失this和event对象的问题(事件回调中的this指向触发元素)

S4.2 可以理解为 this和event对象的值，是由事件传递给 回调函数中的


S5.1 新增需求: 可以在第一次触发事件时，就立刻执行一次回调而不用延迟





3 防抖的实现代码见下:

```js
function debounce(fn, wait){
  let timer
  
  let arguments = arguments

  return function(){
    let context = this
    let args = arguments

    clearTimeout(timer)
    timer = setTimeout(fn.apply(context, args), wait)
  }
}


// 使用方法举例
container.onmousemove = debounce(getUserAction, 1000)  //返回的是匿名函数，作为事件回调
```






















