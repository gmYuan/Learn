# 数组去重

## 目录

1 [预读文档](#1)

2 [实现方式](#2)

  - [2.1 双重循环](#2.1)

  - [2.2 循环+IndexOf](#2.2)

  - [2.3 排序+上一个比值法](#2.3)
 
  - [2.4 filter重写以上两种方法](#2.4)

  - [2.5 object键值对方法](#2.5)

  - [2.6 ES6方法](#2.6)


## <span id="1">一  预读文档</span>

1 阅读文档有:

01.1 [阮一峰— JS的基本语法](https://wangdoc.com/javascript/basic/grammar.html)

阅读原因: 明确break的作用

01.2 [阮一峰— Array对象](https://wangdoc.com/javascript/stdlib/array.html)

阅读原因: 明确数组方法 作用

01.3 [阮一峰— JSON对象](https://wangdoc.com/javascript/stdlib/json.html)

阅读原因: 明确JSON方法 作用

01.4 [深入理解ES6](/)

阅读原因: 了解 Array.from()/ ...扩展运算符/ Set(map)相关

01.5 [ES6的rest参数和扩展运算符](https://segmentfault.com/a/1190000010222698)

阅读原因: 了解 扩展运算符 和 剩余参数的 关系



02.1 [JavaScript专题之 数组去重](https://github.com/mqyqingfeng/Blog/issues/27)

阅读原因: 伢羽出品，必属精品


02.2 [解锁多种JavaScript数组去重姿势](https://juejin.im/post/5b0284ac51882542ad774c45)

阅读原因: 添加了 多种去重方法的粗略性能结果



## <span id="2">二 实现方式 </span>

### <span id="2.1"> 2.1 双重循环 </span>

1 Q: 如何用双重循环实现 数组去重

1 A:

S1 for循环遍历原数组

S2.1 内部循环遍历新数组对象，当内部循环值和外部循环值 相等时，退出内部循环 +  并进行外部循环的下一轮

S2.2 当内部循环值和外部循环值 都不相等时，把当前外部循环值 push到新数组内

S3 最后返回新数组


S4.1 因为第一次时新数组为空，所以不会执行内部循环，需要直接把 原数组第一个元素push到新数组 + 遍历下一轮外部循环

S4.2 因为内部break只能退出内部一层循环(而不会直接进入外部循环的下一轮)，

所以退出内部循环后，会指向同级外部循环的 其他代码，所以不能直接push内容到新数组中(否则退出内部循环后，就会把重复元素加入到 新数组中)


S5.1 因此，push的条件要满足两个: 既能初始化第一个新数组元素，又能在 存在重复时不push到新数组

S5.2 利用break的特性(执行break时,会立刻跳出循环，所以只要触发了break语句，j的数量必然小于 新数组.length）

反之，只要未触发break语句，j++就会自然执行，直到 j的值等于新数组.length，从而自然结束内部循环

```js
var array = [1, 2, 1, '1', '1']

function unique(arr) {
  var res = []
  for (var i = 0; i < arr.length; i++) {
    for (var j = 0; j < res.length; j++) {
      if (arr[i] === res[j]) {
        break
      }
    } // 内层循环

    if (j === res.length){
      res.push(arr[i])
    }

  }  // 外层循环
  return res
}

// 过程分析:
// S1 i=0: j=0, res.length = 0  => 内循环不执行 + 执行push操作, res=[1]
// S2 i=1:
     // j=0, res.length = 1  => 执行内循环 + arr[1] (2)  不等于res[0] (1), 不会触发break
     // j=1, res.length = 1  =>  res=[1,2]

// S3 i=2:
     // j=0, res.length = 2  => 执行内循环 + arr[2] (1)  等于res[0] (1), 触发break
     // 此时 j < res.length ,所以也就不会push到res中

// S4 i=3....
```

### <span id="2.2"> 2.2 循环+IndexOf </span>

S1 循环原数组arr

S2 新数组利用IndexOf判断是否存在，不存在(IndexOf值为-1) 则push到新数组里

```js
var array = [1, 2, 1, "1", "1"]

function unique(arr){
  var res = []
  arr.forEach(member => {
    if (res.indexOf(member) === -1) {
      res.push(member)
    }
  })
  return res
}

console.log(unique(array))  // [1, 2, "1"]
```

### <span id="2.3"> 2.3 排序+上一个比值法 </span>

S1 拷贝原数组+排序，这样相同元素就会序列显示

S2 遍历排序好的数组，和上一值做对比，不同则说明不重复，push到新数组里

S3 注意首个成员不用比较就要push(因为没有前一个值可以比较)

```js
var array = [1, 2, 1, "1", "1"]

function unique(arr){
  var res = []
  var sortArr = arr.concat().sort()
  sortArr.forEach( (member,index,arrSelf) => {
    if (!index || member !== arrSelf[index-1]){  // 如果是第一个元素或者相邻的元素不相同
      res.push(member)
    }
  })
  return res
}

console.log(unique(array))  // [1, "1", 2]
```

### <span id="2.4"> 2.4 filter重写 以上两种方法</span>

1 filter重写 IndexOf方法

S1 用filter筛选原数组arr，返回的值是满足条件是的 一个新数组

S2.1 filer内部 对原数组使用IndexOf(存在则返回该元素第一次出现位置的Index值，不存在则返回-1)

S2.2 因为重复元素的IndexOf返回的是第一次出现的Index值，而不会和它本身的Index值相等

```
var array = [1, 2, 1, "1", "1"]

function unique(arr){
  var res = arr.filter( (member, index, arrself) => {
    return  
  })
  return res
}

console.log(unique(array)) 
```

2 filter 重写 sort排序+对比上一个值方法

```
var array = [1, 2, 1, "1", "1"]

function unique(arr){
  var res = arr.concat().sort().filter( (member, index, arrself) => {
    return !index || member !== arrself[index-1]
  }) 
  return res
}

console.log(unique(array)) 

```

### <span id="2.5"> 2.5 object键值对方法 </span>

1 优点: 可以去重掉对象 和 NAN

2 S1 新建一个空数组对象，把原数组值作为key

S2 利用对象方法hasOwnProperty判断 是否已存在原数组值， 存在则返回false以排除重复成员


S3.1 因为对象的key类型都是字符串，所以会导致"1" / 1 被去重掉

S3.2 所以key需要添加 typeof的信息，来区分 string 和 number类型（第二版）


S4.1 因为typeof 判断对象都是返回 object, 所以非重复对象也都会被排除

S4.2 可以使用JSON.stringify 配合typeof,来识别对象是否重复（第三版）


```
// 第一版
var array = [1, 2, 1, "1", "1", NaN, {value: 1}, {value: 1}, {value: 2}, NaN]

function unique(arr){
  var res = {}
  return  arr.filter((member) => {                  // 返回结果数组
    return res.hasOwnProperty(member) ? false : res[member] = true
  })

console.log(unique(array))  // [1, 2, NaN, {value:1}]


// 第二版
var array = [1, 2, 1, "1", "1", NaN, {value: 1}, {value: 1}, {value: 2}, NaN]

function unique(arr){
  var res = {}
  return  arr.filter((member) => {                  
    return res.hasOwnProperty( typeof member + member) ? false : res[typeof member + member] = true
  })
}

console.log(unique(array))  // [1, 2, "1", NaN, {value:1}]


// 第三版
var array = [1, 2, 1, "1", "1", NaN, {value: 1}, {value: 1}, {value: 2}, NaN]

function unique(arr){
  var res = {}
  return arr.filter( (member) => {
    console.log(typeof member + JSON.stringify(member))
    return res.hasOwnProperty(typeof member + JSON.stringify(member)) ? false : res[typeof member + JSON.stringify(member)] = true
  })
}

console.log(unique(array))  // [1, 2, "1", NaN, {value:1}, {value:2}]
```


### <span id="2.6"> 2.6 ES6方法 </span>

S1 Set对象可以用于去重

S2 ...扩展运算符/Array.from可以把可迭代对象 转化为数组

```
var array = [1, 2, 1, "1", "1", NaN, {value: 1}, {value: 1}, {value: 2}, NaN]

function unique(arr){
  return [...new Set(arr)]
}

console.log(unique(array))  // [1, 2, "1", NaN, {value: 1}, {value: 1}, {value: 2}]


// 也就是
var res = (arr) => [...new Set(arr)]
```



