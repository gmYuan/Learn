# 拷贝之 数据类型 + 深浅拷贝含义

目录:

1 [预读文档](#1)

2 [数据类型](#2)

3 [深浅拷贝的含义](#3)



## <span id="1">1 预读文档 </span>

1 [JS 深拷贝vs浅拷贝](https://juejin.im/post/59ac1c4ef265da248e75892b)

阅读原因: 直到实现之前的含义都简洁易懂



## <span id="2"> 2 数据类型 </span>

1 Q: JS的基础类型 和 引用类型的区别是什么

A: S1.1 JS中，基础类型的值保存在栈中

S1.2 而引用类型的值保存在堆中，变量在栈中的值，只是指向堆地址的 指针


S2.1 基本类型的值是 不可变的，即使是字符串修改后是返回了新的字符串，原字符串不会被修改

S2.2 引用类型是可以直接改变其值的

```js

// 基本类型值不会改变
var str = "abc"
str[0]="f"    
console.log(str)          // 'abc'

// 引用类型的值是 可变的
var arr = [1,2,3]
arr[0] = 6
console.log(arr)         // [6, 2, 3]

```

S3.1 基本类型的比较是 根据值是否相等

S3.2 引用类型的比较是 根据是否是同一个对象地址


S4.1 基本类型赋值时，是直接内存栈中保存一个值，变量之间互不影响 (传值)

S4.2 引用类型赋值时，是在内存栈中保存同一个对象的地址，变量之间互相影响  (传址)


## <span id="3"> 3 深浅拷贝的含义 </span>

1 Q: JS里，赋值 和 浅拷贝的区别是什么，浅拷贝和深拷贝的区别是什么

A: S1 直接看下图即可:

[赋值/浅拷贝/深拷贝的区别](http://ponk9r4je.bkt.clouddn.com/deepCopy.png)


S2 赋值- 浅拷贝: 赋值中，对象内 基础类型数据改变了会影响原对象，但浅拷贝不会

S3 浅拷贝- 深拷贝: 浅拷贝中，对象内的 子对象改变了会影响原对象，但深拷贝不会


S4 示例代码见下

```js
let obj1 = {
  name: 'star',
  age: 18,
  friends: [10, [20, 30], [40,50] ]
}

let obj2 = obj1  // 直接赋值

let obj3 = shallowCopy(obj1)   // 浅拷贝，具体实现见代码最下


// 对象内的基础类型
obj2.age = 20
obj3.age = 22
console.log(obj1)   // {name: "star", age: 20, friends: Array(3)}
console.log(obj2)   // {name: "star", age: 20, friends: Array(3)}
console.log(obj3)   // {name: "star", age: 22, friends: Array(3)}


// 对象内的引用类型

obj2.friends[0] = 1
obj3.friends[1] = [2,3]
console.log(obj1)       // {... age: 20, friends: [1, [2,3], [40.50] ]}
console.log(obj2)       // {... age: 20, friends: [1, [2,3], [40.50] ]}
console.log(obj3)       // {... age: 22, friends: [1, [2,3], [40.50] ]}


// 浅拷贝的实现方法
function shallowCopy(src){
  let target = {}
  for (let key in src){
    if (src.hasOwnProperty(key)){
      target[key] = src[key]
    }
  } 
  return target

}

```



