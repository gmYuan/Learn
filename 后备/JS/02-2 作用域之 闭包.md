# 作用域之 闭包

目录:

1 [预读文档](#1)

2 [什么是闭包](#2)

3 [闭包的实质](#3)

4 [闭包的作用](#4)

5 [闭包的问题](#5)


## <span id="1"> 1 预读文档 </span>

1 [中高级前端面试](#1)

阅读原因: 提纲挈领，参考回答 简明重点



## <span id="2"> 2 什么是闭包</span>

1 Q: 什么是闭包

A: 

S1 广义上的闭包，是指一个函数中可以访问在该函数 外部的变量，即 `闭包= 函数 + 函数能够访问的自由变量`

S2 实践的闭包，满足以下条件才是闭包:

> 函数在内部引用了自由变量

> 函数所属的父级上下文已销毁，但它仍然存在（比如，内部函数从父函数中返回）


S3 示例代码:

```js
function addone(number){
  var result = number
  function add(){
    result++
    return result
  }
  return add
}

var foo = addone(5)
foo()                 //6

```

## <span id="3"> 3 闭包的实质</span>

1 Q: 闭包的实质是什么

A: S0 闭包的实质，是作用域链机制的副作用；

只要子函数上下文中的Scope对象里的 [[scope]]仍然保存着父级的变量对象和作用域链，

哪怕父函数被销毁了，也依然可以继续访问到 父级上下文的变量对象


S1 继续用上述代码举例

```js
function addone(number){
  var result = number
  function add(){
    result++
    return result
  }
  return add
}

var foo = addone(5)
foo()                 //6


/*
过程分析如下

S1.1 调用全局代码，产生执行上下文，即 ECStack = [globalContext]

S1.2 进入准备阶段，产生VO + 执行全局代码

S1.3 调用addone函数，创建addone执行上下文，即 ECStack = [addoneContext, globalContext]   

S1.4 进入addone准备阶段，生成adoneContext.AO + add生成add.[[scope]] = [adoneContext.AO,globalContext.VO]

S1.5 进入addone执行阶段，赋值addoneContext.AO值

S1.6 执行完addone函数，其执行上下文销毁出栈，即 ECStack = [globalContext]

S1.7 执行add/foo函数， 生成上下文addContext

S1.8 生成addContext.AO + addContext.Scope = [AO, [[scope]]]

S1.9 当真正执行add()函数时,查找result的变量是读取Scope的值，也就是作用域链

所以，虽然addoneContext被销毁了，但只要其AO被其他上下文环境引用了，其AO就不会被销毁
*/
```


## <span id="4"> 4 闭包的作用</span>

1 for循环 函数数组 内部变量的正确绑定

```js
// 例1：for循环

var data = []
for (var i = 0; i < 3; i++ ){
  data[i] = function(){
    console.log(i)
  }
}

data[0]()  //3， 定义并执行data函数时，其作用域链为 Scope = [AO, gloContext.VO]
data[1]()  //3
data[2]()  //3
```

改成闭包的结果如下:

```js
var data = [];
for (var i = 0; i < 3; i++ ){
  data[i] = !function(i){
    return function(){
      console.log(i)
    }
  }(i)
}

data[0]()  //0，定义并执行data函数时， 其作用域链为 `Scope = [AO, 匿名函数Context.AO , globalContext.VO]`
data[1]()  //1
data[2]()  //2
```


## <span id="5"> 5 闭包的问题</span>

1 闭包的缺点: 常驻内存会增大内存使用量

因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗
