# 面向对象之 原型与原型链

目录:

1 [预读文档](#1)

2 [什么是原型](#2) 

3 [什么是原型链](#3)

4 [函数和对象 的创建过程](#4)

  
## <span id="1"> 1 预读文档 </span>

1 [JS深入之 从原型到原型链](https://github.com/mqyqingfeng/Blog/issues/2)

阅读原因: 原型和原型链概念的最佳介绍博文

2 [JS中先有Object还是先有Function](https://www.zhihu.com/question/35442532)

阅读原因: 关于Object和Function的关系介绍

3 [深度解析原型中的各个难点](https://github.com/KieSun/Dream/issues/2)

阅读原因: Object和Function的关系很清晰



## <span id="2"> 2 什么是原型 </span>

1 Q: 什么是原型

A:

S1.1 原型是一个对象

S1.2 JS中每个对象A 都有一个__proto__属性，它指向一个对象B，这个对象B就是原型

S1.3 对象A可以访问对象B中的属性，为了便于理解，我们可以把原型对象B看做是A的 "父对象"


S2.1 可以通过new关键字构造出实例对象的函数，称为构造函数

S2.2 构造函数有一个prototype属性，它的值也指向原型对象


S3 所以，`实例对象.__proto__ = 构造函数.__prototype`

用一张图表示为: [实例对象、构造函数、原型对象关系](https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/prototype2.png)



2 Q: 什么是constructor

A: 

S1 每个原型对象都有一个constructor属性，指向其关联的构造函数

用图表示为: [实例原型对象 与 构造函数](https://user-gold-cdn.xitu.io/2019/2/14/168e9d9b940c4c6f?imageView2/0/w/1280/h/960/ignore-error/1)

S2 因为实例对象继承了原型属性，所以，实例对象.constructor === 构造函数 也为真

S3 用代码表示为:

```js
function Person() {
  ......
}

var person = new Person();

console.log(person.__proto__ == Person.prototype)                 // true
console.log(Person.prototype.constructor == Person)               // true

// Object.getPrototypeOf方法,可以获得实例对象的 原型对象

console.log(Object.getPrototypeOf(person) === Person.prototype)   // true
```



## <span id="3"> 3 什么是原型链 </span>

1 Q: 什么是原型链

A: 

S1.1 每个对象都有一个原型对象，原型对象也有原型对象，一层一层的原型对象就构成了原型链

S1.2 通过原型链，可以实现属性的共享和继承


S2 原型链的属性查找机制:

会依次在 实例对象-> 原型对象A-> A.__proto_对象->  .....-> Object.prototype中查找属性


S3 原型链的属性修改机制:

只会修改实例对象 本身的属性，如果不存在，则添加该属性


蓝色部分表示为: [原型链](https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/prototype5.png)



## <span id="4"> 4 函数和对象 的创建过程 </span>

1 `Object.prototype`

S1 浏览器内置就实现的 key-value对象，它是一个对象 + 对象都有__proto__属性

S2 ES规定了: `Object.prototype.__proto = null`


2 `Function.prototype`

S1 浏览器内置就实现的 key-value

S2 规定了: `Function.prototype.__proto__ = Object.prototype`


3 `Function构造函数`

S1 构造函数对象 具有 __proto__属性 + prototype属性

S2 规定了: `Function.__proto__ = Function.prototype`，就只是这么规定的

S3 `Function.prototype = Function.prototype`


4 `Object构造函数`

S1 构造函数对象 具有 __proto__属性 + prototype属性

S2 Object构造函数 是由Function构造出的实例对象，所以 `Object.__proto__ = Function.prototype`

S3 `Object.prototype = Object.prototype`


5 `自定义函数的 实例对象`

S1 实例对象fn是由 自定义构造函数Fn构造出的，所以 `fn.__proto__ = Fn.prototype`

S2 自定义构造函数Fn 是由 Function构造的实例，所以 `Fn.__proto__ = Function.prototype` ，且`Fn.prototype = Fn.prototype`

S3 Fn.prototype是一个对象，它是由Object构造出的实例，所以 `Fn.prototype.__proto__ = Object.prototype`


综合上面所有内容，一张经典图理解为:
![PSHSEj.jpg](https://s1.ax1x.com/2018/06/21/PSHSEj.jpg)

小结一下:

> 1 `Function.prototype` 和 `Object.prototype` 是两个特殊的对象，他们由引擎来创建

> 2 除了以上两个特殊对象，其他对象都是通过构造器 `new` 出来的

> 3 构造函数的 __proto__原型属性 与 它的prototype属性 不是一回事

> 3.1 前者是它作为对象时的属性，表示这个函数是谁生的, 或者说是在谁的基础上扩展来的

> 3.2 后者是它作为一个构造函数时特有的属性，即用它来new一个对象时，这个被new出来的对象是用谁做模版的
