<!DOCTYPE html>
<html lang="zh-Hans">
<head>
	<meta charset="UTF-8">
  <title>子组件传入父组件数据- 使用model</title>
  <style>
  	#app {margin-bottom: 30px;}
  	li {list-style: none;}
  </style>
  
</head>

<body>
	<div id="app">
		<!-- 需求: 子组件可以修改父组件金额数据 + 使用model实现 -->
		<div>
			当前父组件的数据金额是:  {{price}}
		</div>

		<child-component :price="price" v-model="price"></child-component>

		<!-- 操作步骤: -->
		<!-- S1 子组件绑定+ props接收父组件的属性值 -->
		<!-- S2 设置点击事件，绑定回调处理fn -->
		<!-- S3 fn里发布input事件 + 传出处理后的值 -->
		<!-- S4 在 渲染到父组件页面的组件标签上，用v-model绑定要想改变的值a，传入的值就会覆盖到a上 -->

		<!-- S5.1 原因是 v-model相当于是一个语法糖，他会自动订阅input事件 + 绑定一个value特性，值是绑定的data值a -->

		<!-- S5.2 当触发事件后，a的值就会更新成 传入的值 -->

	</div>

	<script src="https://cdn.bootcss.com/vue/2.6.8/vue.js"></script> 
	<!-- <script> Vue.config.devtools = true</script> -->

	<script>
    let app = new Vue({
      el: '#app',
      data: {
				price: 2000
      },
      components: {
      	'child-component': {
      		props:['price'],
      		data(){
      			return {
      				count: this.price
      			}
      		},
      		template: `
      			<div style="margin-top: 20px">
      			  <button @click ="addprice">增加100金</button>
						</div>
      		`,
      		methods: {
      			addprice(){
      				this.count = this.count + 100
      				this.$emit('input', this.count)
      			}
      		}
      	}
      },
      methods: {
      	showprice(value){
      		this.price = value
      	}
      }
      	
    })
      
	</script>

</body>
</html>

